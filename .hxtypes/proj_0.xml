<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<typedef path="Console" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/Console.hx">
		<c path="mconsole.Console"/>
		<haxe_doc>An alias for mconsole.Console</haxe_doc>
	</typedef>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<customReplace public="1" set="method" line="74">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="70">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="63">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="58">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="41">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/flash/_std/IntHash.hx">
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1">
		<haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc>
		<meta><m n="interface"/></meta>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="ash.GenericListIterator" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/GenericListIterator.hx">
		<next public="1" set="method" line="21"><f a=""><c path="ash.GenericListIterator.TNode"/></f></next>
		<hasNext public="1" set="method" line="16"><f a=""><e path="Bool"/></f></hasNext>
		<previous><t path="ash._GenericListIterator.HasNext"><c path="ash.GenericListIterator.TNode"/></t></previous>
		<new public="1" set="method" line="11"><f a="head">
	<c path="ash.GenericListIterator.TNode"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* An iterator class for any linked lists that
 * has "next" variable in its elements.</haxe_doc>
	</class>
	<typedef path="ash._GenericListIterator.HasNext" params="T" file="/usr/lib/haxe/lib/ash/1,5/ash/GenericListIterator.hx" private="1" module="ash.GenericListIterator"><a><next><c path="ash._GenericListIterator.HasNext.T"/></next></a></typedef>
	<class path="ash.ObjectMap" params="K:T" file="/usr/lib/haxe/lib/ash/1,5/ash/ObjectMap.hx">
		<nextObjectID line="25" static="1">
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</nextObjectID>
		<set public="1" get="inline" set="null" line="161"><f a="key:value">
	<c path="ash.ObjectMap.K"/>
	<c path="ash.ObjectMap.T"/>
	<e path="Void"/>
</f></set>
		<remove public="1" get="inline" set="null" line="143"><f a="key">
	<c path="ash.ObjectMap.K"/>
	<e path="Void"/>
</f></remove>
		<keys public="1" get="inline" set="null" line="128"><f a=""><t path="Iterator"><c path="ash.ObjectMap.K"/></t></f></keys>
		<iterator public="1" get="inline" set="null" line="105"><f a=""><t path="Iterator"><c path="ash.ObjectMap.T"/></t></f></iterator>
		<getID get="inline" set="null" line="74">
			<f a="key">
				<c path="ash.ObjectMap.K"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</getID>
		<get public="1" get="inline" set="null" line="59"><f a="key">
	<c path="ash.ObjectMap.K"/>
	<c path="ash.ObjectMap.T"/>
</f></get>
		<exists public="1" get="inline" set="null" line="44"><f a="key">
	<c path="ash.ObjectMap.K"/>
	<e path="Bool"/>
</f></exists>
		<dictionary>
			<c path="flash.utils.TypedDictionary">
				<c path="ash.ObjectMap.K"/>
				<c path="ash.ObjectMap.T"/>
			</c>
			<haxe_doc>@private</haxe_doc>
		</dictionary>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="ash.core.IFamily" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/IFamily.hx" interface="1">
		<cleanUp public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* The family is about to be discarded. Clean up all properties as necessary. Usually, you will
     * want to empty the NodeList at this time.</haxe_doc>
		</cleanUp>
		<componentRemovedFromEntity public="1" set="method">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* A component has been removed from an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.</haxe_doc>
		</componentRemovedFromEntity>
		<componentAddedToEntity public="1" set="method">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* A component has been added to an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.</haxe_doc>
		</componentAddedToEntity>
		<removeEntity public="1" set="method">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An entity has been removed from the engine. If it's in this family's NodeList it should be removed.</haxe_doc>
		</removeEntity>
		<newEntity public="1" set="method">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* An entity has been added to the engine. It may already have components so test the entity
     * for inclusion in this family's NodeList.</haxe_doc>
		</newEntity>
		<nodeList public="1" set="null">
			<c path="ash.core.NodeList"><c path="ash.core.IFamily.TNode"/></c>
			<haxe_doc>* Returns the NodeList managed by this class. This should be a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. never recreate the list,
     * always modify it in place.</haxe_doc>
		</nodeList>
		<haxe_doc>* The interface for classes that are used to manage NodeLists (set as the familyClass property
 * in the Engine object). Most developers don't need to use this since the default implementation
 * is used by default and suits most needs.</haxe_doc>
		<meta><m n="interface"/></meta>
	</class>
	<class path="ash.core.ComponentMatchingFamily" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/ComponentMatchingFamily.hx">
		<implements path="ash.core.IFamily"><c path="ash.core.ComponentMatchingFamily.TNode"/></implements>
		<cleanUp public="1" set="method" line="159">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all nodes from the NodeList.</haxe_doc>
		</cleanUp>
		<releaseNodePoolCache set="method" line="150">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Releases the nodes that were added to the node pool during this engine update, so they can
     * be reused.</haxe_doc>
		</releaseNodePoolCache>
		<removeIfMatch set="method" line="127">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes the entity if it is in this family's NodeList.</haxe_doc>
		</removeIfMatch>
		<addIfMatch set="method" line="102">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* If the entity is not in this family's NodeList, tests the components of the entity to see
     * if it should be in this NodeList and adds it if so.</haxe_doc>
		</addIfMatch>
		<removeEntity public="1" set="method" line="93">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called by the engine when an entity has been rmoved from it. We check if the entity is in
     * this family's NodeList and remove it if so.</haxe_doc>
		</removeEntity>
		<componentRemovedFromEntity public="1" set="method" line="81">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called by the engine when a component has been removed from an entity. We check if the removed component
     * is required by this family's NodeList and if so, we check if the entity is in this this NodeList and
     * remove it if so.</haxe_doc>
		</componentRemovedFromEntity>
		<componentAddedToEntity public="1" set="method" line="71">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called by the engine when a component has been added to an entity. We check if the entity is not in
     * this family's NodeList and should be, and add it if appropriate.</haxe_doc>
		</componentAddedToEntity>
		<newEntity public="1" set="method" line="62">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called by the engine when an entity has been added to it. We check if the entity should be in
     * this family's NodeList and add it if appropriate.</haxe_doc>
		</newEntity>
		<init set="method" line="45">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Initialises the class. Creates the nodelist and other tools. Analyses the node to determine
     * what component types the node requires.</haxe_doc>
		</init>
		<engine><c path="ash.core.Engine"/></engine>
		<nodePool><c path="ash.core.NodePool"><c path="ash.core.ComponentMatchingFamily.TNode"/></c></nodePool>
		<components><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></components>
		<nodeClass><c path="Class"><c path="ash.core.ComponentMatchingFamily.TNode"/></c></nodeClass>
		<entities><c path="ash.ObjectMap">
	<c path="ash.core.Entity"/>
	<c path="ash.core.ComponentMatchingFamily.TNode"/>
</c></entities>
		<nodeList public="1" set="null">
			<c path="ash.core.NodeList"><c path="ash.core.ComponentMatchingFamily.TNode"/></c>
			<haxe_doc>* The nodelist managed by this family. This is a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,
     * we always modify it in place.</haxe_doc>
		</nodeList>
		<new public="1" set="method" line="34">
			<f a="nodeClass:engine">
				<c path="Class"><c path="ash.core.ComponentMatchingFamily.TNode"/></c>
				<c path="ash.core.Engine"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The constructor. Creates a ComponentMatchingFamily to provide a NodeList for the
     * given node class.
     *
     * @param nodeClass The type of node to create and manage a NodeList for.
     * @param engine The engine that this family is managing teh NodeList for.</haxe_doc>
		</new>
		<haxe_doc>* The default class for managing a NodeList. This class creates the NodeList and adds and removes
 * nodes to/from the list as the entities and the components in the engine change.
 *
 * It uses the basic entity matching pattern of an entity system - entities are added to the list if
 * they contain components matching all the public properties of the node class.</haxe_doc>
	</class>
	<class path="ash.core.Engine" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/core/Engine.hx">
		<update public="1" set="method" line="288">
			<f a="time">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Update the engine. This causes the engine update loop to run, calling update on all the
     * systems in the engine.
     *
     * <p>The package ash.tick contains classes that can be used to provide
     * a steady or variable tick that calls this update method.</p>
     *
     * @time The duration, in seconds, of this update step.]]></haxe_doc>
		</update>
		<removeAllSystems public="1" set="method" line="270">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Remove all systems from the engine.</haxe_doc>
		</removeAllSystems>
		<removeSystem public="1" set="method" line="260">
			<f a="system">
				<c path="ash.core.System"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Remove a system from the engine.
     *
     * @param system The system to remove from the engine.</haxe_doc>
		</removeSystem>
		<get_systems get="inline" set="null" line="249">
			<f a=""><t path="Iterable"><c path="ash.core.System"/></t></f>
			<haxe_doc>* Returns an iterator of all systems in the engine.</haxe_doc>
		</get_systems>
		<getSystem public="1" params="TSystem" set="method" line="241">
			<f a="type">
				<c path="Class"><c path="getSystem.TSystem"/></c>
				<c path="getSystem.TSystem"/>
			</f>
			<haxe_doc>* Get the system instance of a particular type from within the engine.
     *
     * @param type The type of system
     * @return The instance of the system type that is in the engine, or
     * null if no systems of this type are in the engine.</haxe_doc>
		</getSystem>
		<addSystem public="1" set="method" line="226">
			<f a="system:priority">
				<c path="ash.core.System"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a system to the engine, and set its priority for the order in which the
     * systems are updated by the engine update loop.
     *
     * <p>The priority dictates the order in which the systems are updated by the engine update
     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is
     * updated before a priority of 2.</p>
     *
     * @param system The system to add to the engine.
     * @param priority The priority for updating the systems during the engine loop. A
     * lower number means the system is updated sooner.]]></haxe_doc>
		</addSystem>
		<releaseNodeList public="1" params="TNode" set="method" line="204">
			<f a="nodeClass">
				<c path="Class"><c path="releaseNodeList.TNode"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* If a NodeList is no longer required, this method will stop the engine updating
     * the list and will release all references to the list within the framework
     * classes, enabling it to be garbage collected.
     *
     * <p>It is not essential to release a list, but releasing it will free
     * up memory and processor resources.</p>
     *
     * @param nodeClass The type of the node class if the list to be released.]]></haxe_doc>
		</releaseNodeList>
		<getNodeList public="1" params="TNode" set="method" line="179">
			<f a="nodeClass">
				<c path="Class"><c path="getNodeList.TNode"/></c>
				<c path="ash.core.NodeList"><c path="getNodeList.TNode"/></c>
			</f>
			<haxe_doc><![CDATA[* Get a collection of nodes from the engine, based on the type of the node required.
     *
     * <p>The engine will create the appropriate NodeList if it doesn't already exist and
     * will keep its contents up to date as entities are added to and removed from the
     * engine.</p>
     *
     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>
     *
     * @param nodeClass The type of node required.
     * @return A linked list of all nodes of this type from all entities in the engine.]]></haxe_doc>
		</getNodeList>
		<componentRemoved set="method" line="158">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</componentRemoved>
		<componentAdded set="method" line="146">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</componentAdded>
		<get_entities get="inline" set="null" line="137">
			<f a=""><t path="Iterable"><c path="ash.core.Entity"/></t></f>
			<haxe_doc>* Returns an iterator of all entities in the engine.</haxe_doc>
		</get_entities>
		<removeAllEntities public="1" set="method" line="126">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Remove all entities from the engine.</haxe_doc>
		</removeAllEntities>
		<getEntityByName public="1" get="inline" set="null" line="118">
			<f a="name">
				<c path="String"/>
				<c path="ash.core.Entity"/>
			</f>
			<haxe_doc>* Get an entity based n its name.
     *
     * @param name The name of the entity
     * @return The entity, or null if no entity with that name exists on the engine</haxe_doc>
		</getEntityByName>
		<entityNameChanged set="method" line="103"><f a="entity:oldName">
	<c path="ash.core.Entity"/>
	<c path="String"/>
	<e path="Void"/>
</f></entityNameChanged>
		<removeEntity public="1" set="method" line="89">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Remove an entity from the engine.
     *
     * @param entity The entity to remove.</haxe_doc>
		</removeEntity>
		<addEntity public="1" set="method" line="67">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add an entity to the engine.
     *
     * @param entity The entity to add.</haxe_doc>
		</addEntity>
		<familyClass public="1">
			<c path="Class"><c path="ash.core.IFamily"><d/></c></c>
			<haxe_doc>* The class used to manage node lists. In most cases the default class is sufficient
     * but it is exposed here so advanced developers can choose to create and use a
     * different implementation.
     *
     * The class must implement the IFamily interface.</haxe_doc>
		</familyClass>
		<updateComplete public="1" set="null">
			<c path="ash.signals.Signal0"/>
			<haxe_doc>* Dispatched when the update loop ends. If you want to add and remove systems from the
     * engine it is usually best not to do so during the update loop. To avoid this you can
     * listen for this signal and make the change when the signal is dispatched.</haxe_doc>
		</updateComplete>
		<entityRemoved public="1" set="null"><c path="ash.signals.Signal1"><c path="ash.core.Entity"/></c></entityRemoved>
		<entityAdded public="1" set="null"><c path="ash.signals.Signal1"><c path="ash.core.Entity"/></c></entityAdded>
		<updating public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>* Indicates if the engine is currently in its update loop.</haxe_doc>
		</updating>
		<families><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="ash.core.IFamily"><d/></c>
</c></families>
		<systemList><c path="ash.core.SystemList"/></systemList>
		<entityList><c path="ash.core.EntityList"/></entityList>
		<entityNames><c path="Hash"><c path="ash.core.Entity"/></c></entityNames>
		<systems public="1" get="get_systems" set="null"><t path="Iterable"><c path="ash.core.System"/></t></systems>
		<entities public="1" get="get_entities" set="null"><t path="Iterable"><c path="ash.core.Entity"/></t></entities>
		<new public="1" set="method" line="49"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The Engine class is the central point for creating and managing your game state. Add
 * entities and systems to the engine, and fetch families of nodes from the engine.</haxe_doc>
	</class>
	<class path="ash.core.Entity" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/core/Entity.hx">
		<nameCount line="26" static="1"><c path="Int"/></nameCount>
		<has public="1" set="method" line="154">
			<f a="componentClass">
				<c path="Class"><d/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Does the entity have a component of a particular type.
     *
     * @param componentClass The class of the component sought.
     * @return true if the entity has a component of the type, false if not.</haxe_doc>
		</has>
		<getAll public="1" set="method" line="139">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* Get all components from the entity.
     *
     * @return An array containing all the components that are on the entity.</haxe_doc>
		</getAll>
		<get public="1" params="T" set="method" line="128">
			<f a="componentClass">
				<c path="Class"><d/></c>
				<c path="get.T"/>
			</f>
			<haxe_doc>* Get a component from the entity.
     *
     * @param componentClass The class of the component requested.
     * @return The component, or null if none was found.</haxe_doc>
		</get>
		<remove public="1" params="T" set="method" line="109">
			<f a="componentClass">
				<c path="Class"><d/></c>
				<c path="remove.T"/>
			</f>
			<haxe_doc>* Remove a component from the entity.
     *
     * @param componentClass The class of the component to be removed.
     * @return the component, or null if the component doesn't exist in the entity</haxe_doc>
		</remove>
		<add public="1" params="T" set="method" line="89">
			<f a="component:?componentClass">
				<c path="add.T"/>
				<c path="Class"><d/></c>
				<c path="ash.core.Entity"/>
			</f>
			<haxe_doc><![CDATA[* Add a component to the entity.
     *
     * @param component The component object to add.
     * @param componentClass The class of the component. This is only necessary if the component
     * extends another component class and you want the framework to treat the component as of
     * the base class type. If not set, the class type is determined directly from the component.
     *
     * @return A reference to the entity. This enables the chaining of calls to add, to make
     * creating and configuring entities cleaner. e.g.
     *
     * <code>var entity:Entity = new Entity()
     *     .add(new Position(100, 200)
     *     .add(new Display(new PlayerClip());</code>]]></haxe_doc>
		</add>
		<set_name get="inline" set="null" line="62"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<components public="1" set="null"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<d/>
</c></components>
		<next public="1"><c path="ash.core.Entity"/></next>
		<previous public="1"><c path="ash.core.Entity"/></previous>
		<nameChanged public="1">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<c path="String"/>
			</c>
			<haxe_doc>* Dispatched when the name of the entity changes. Used internally by the engine to track entities based on their names.</haxe_doc>
		</nameChanged>
		<componentRemoved public="1" set="null">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
			</c>
			<haxe_doc>* This signal is dispatched when a component is removed from the entity.</haxe_doc>
		</componentRemoved>
		<componentAdded public="1" set="null">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<c path="Class"><d/></c>
			</c>
			<haxe_doc>* This signal is dispatched when a component is added to the entity.</haxe_doc>
		</componentAdded>
		<name public="1" set="set_name">
			<c path="String"/>
			<haxe_doc>* Optional, give the entity a name. This can help with debugging and with serialising the entity.</haxe_doc>
		</name>
		<new public="1" set="method" line="49"><f a="?name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* An entity is composed from components. As such, it is essentially a collection object for components.
 * Sometimes, the entities in a game will mirror the actual characters and objects in the game, but this
 * is not necessary.
 *
 * <p>Components are simple value objects that contain data relevant to the entity. Entities
 * with similar functionality will have instances of the same components. So we might have
 * a position component</p>
 *
 * <p><code>class PositionComponent
 * {
 *   public var x:Float;
 *   public var y:Float;
 * }</code></p>
 *
 * <p>All entities that have a position in the game world, will have an instance of the
 * position component. Systems operate on entities based on the components they have.</p>]]></haxe_doc>
	</class>
	<class path="ash.core.EntityList" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/core/EntityList.hx">
		<iterator public="1" set="method" line="59"><f a=""><t path="Iterator"><c path="ash.core.Entity"/></t></f></iterator>
		<removeAll public="1" set="method" line="47"><f a=""><e path="Void"/></f></removeAll>
		<remove public="1" set="method" line="34"><f a="entity">
	<c path="ash.core.Entity"/>
	<e path="Void"/>
</f></remove>
		<add public="1" set="method" line="18"><f a="entity">
	<c path="ash.core.Entity"/>
	<e path="Void"/>
</f></add>
		<tail public="1" set="null"><c path="ash.core.Entity"/></tail>
		<head public="1" set="null"><c path="ash.core.Entity"/></head>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* An internal class for a linked list of entities. Used inside the framework for
 * managing the entities.</haxe_doc>
	</class>
	<class path="ash.core.Node" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/Node.hx">
		<next public="1">
			<c path="ash.core.Node.TNode"/>
			<haxe_doc>* Used by the NodeList class. The next node in a node list.</haxe_doc>
		</next>
		<previous public="1">
			<c path="ash.core.Node.TNode"/>
			<haxe_doc>* Used by the NodeList class. The previous node in a node list.</haxe_doc>
		</previous>
		<entity public="1">
			<c path="ash.core.Entity"/>
			<haxe_doc>* The entity whose components are included in the node.</haxe_doc>
		</entity>
		<haxe_doc><![CDATA[* The base class for a node.
 *
 * <p>A node is a set of different components that are required by a system.
 * A system can request a collection of nodes from the engine. Subsequently the Engine object creates
 * a node for every entity that has all of the components in the node class and adds these nodes
 * to the list obtained by the system. The engine keeps the list up to date as entities are added
 * to and removed from the engine and as the components on entities change.</p>]]></haxe_doc>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<class path="ash.core.NodeList" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/NodeList.hx">
		<merge set="method" line="283"><f a="head1:head2:sortFunction">
	<c path="ash.core.NodeList.TNode"/>
	<c path="ash.core.NodeList.TNode"/>
	<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
	<c path="ash.core.NodeList.TNode"/>
</f></merge>
		<mergeSort public="1" set="method" line="251">
			<f a="sortFunction">
				<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs a merge sort on the node list. In general, merge sort is more efficient than insertion sort
     * with long lists that are very unsorted.
     *
     * <p>The sort function takes two nodes and returns an Int.</p>
     *
     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) : Int</code></p>
     *
     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater
     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter.</p>
     *
     * <p>This merge sort implementation creates and uses a single Vector during the sort operation.</p>]]></haxe_doc>
		</mergeSort>
		<insertionSort public="1" set="method" line="179">
			<f a="sortFunction">
				<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs an insertion sort on the node list. In general, insertion sort is very efficient with short lists
     * and with lists that are mostly sorted, but is inefficient with large lists that are randomly ordered.
     *
     * <p>The sort function takes two nodes and returns an Int.</p>
     *
     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) : Int</code></p>
     *
     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater
     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter
     * and the original order will be retained.</p>
     *
     * <p>This insertion sort implementation runs in place so no objects are created during the sort.</p>]]></haxe_doc>
		</insertionSort>
		<swap public="1" set="method" line="120">
			<f a="node1:node2">
				<c path="ash.core.NodeList.TNode"/>
				<c path="ash.core.NodeList.TNode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Swaps the positions of two nodes in the list. Useful when sorting a list.</haxe_doc>
		</swap>
		<iterator public="1" set="method" line="111"><f a=""><t path="Iterator"><c path="ash.core.NodeList.TNode"/></t></f></iterator>
		<get_empty get="inline" set="null" line="106"><f a=""><e path="Bool"/></f></get_empty>
		<empty public="1" get="get_empty" set="null">
			<e path="Bool"/>
			<haxe_doc>* true if the list is empty, false otherwise.</haxe_doc>
		</empty>
		<removeAll public="1" set="method" line="88"><f a=""><e path="Void"/></f></removeAll>
		<remove public="1" set="method" line="71"><f a="node">
	<c path="ash.core.NodeList.TNode"/>
	<e path="Void"/>
</f></remove>
		<add public="1" set="method" line="54"><f a="node">
	<c path="ash.core.NodeList.TNode"/>
	<e path="Void"/>
</f></add>
		<nodeRemoved public="1" set="null">
			<c path="ash.signals.Signal1"><c path="ash.core.NodeList.TNode"/></c>
			<haxe_doc><![CDATA[* A signal that is dispatched whenever a node is removed from the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was removed.</p>]]></haxe_doc>
		</nodeRemoved>
		<nodeAdded public="1" set="null">
			<c path="ash.signals.Signal1"><c path="ash.core.NodeList.TNode"/></c>
			<haxe_doc><![CDATA[* A signal that is dispatched whenever a node is added to the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was added.</p>]]></haxe_doc>
		</nodeAdded>
		<tail public="1" set="null">
			<c path="ash.core.NodeList.TNode"/>
			<haxe_doc>* The last item in the node list, or null if the list contains no nodes.</haxe_doc>
		</tail>
		<head public="1" set="null">
			<c path="ash.core.NodeList.TNode"/>
			<haxe_doc>* The first item in the node list, or null if the list contains no nodes.</haxe_doc>
		</head>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[* A collection of nodes.
 *
 * <p>Systems within the engine access the components of entities via NodeLists. A NodeList contains
 * a node for each Entity in the engine that has all the components required by the node. To iterate
 * over a NodeList, start from the head and step to the next on each loop, until the returned value
 * is null. Or just use for in syntax.</p>
 *
 * <p>for (node in nodeList)
 * {
 *   // do stuff
 * }</p>
 *
 * <p>It is safe to remove items from a nodelist during the loop. When a Node is removed form the
 * NodeList it's previous and next properties still point to the nodes that were before and after
 * it in the NodeList just before it was removed.</p>]]></haxe_doc>
	</class>
	<typedef path="ash.core.SortFunction" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/NodeList.hx" module="ash.core.NodeList"><f a=":">
	<c path="ash.core.SortFunction.TNode"/>
	<c path="ash.core.SortFunction.TNode"/>
	<c path="Int"/>
</f></typedef>
	<class path="ash.core.NodePool" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/core/NodePool.hx">
		<releaseCache public="1" set="method" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Releases all nodes from the cache into the pool</haxe_doc>
		</releaseCache>
		<cache public="1" set="method" line="56">
			<f a="node">
				<c path="ash.core.NodePool.TNode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a node to the cache</haxe_doc>
		</cache>
		<dispose public="1" set="method" line="46">
			<f a="node">
				<c path="ash.core.NodePool.TNode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a node to the pool.</haxe_doc>
		</dispose>
		<get public="1" set="method" line="28">
			<f a=""><c path="ash.core.NodePool.TNode"/></f>
			<haxe_doc>* Fetches a node from the pool.</haxe_doc>
		</get>
		<cacheTail><c path="ash.core.NodePool.TNode"/></cacheTail>
		<nodeClass><c path="Class"><c path="ash.core.NodePool.TNode"/></c></nodeClass>
		<tail><c path="ash.core.NodePool.TNode"/></tail>
		<new public="1" set="method" line="20">
			<f a="nodeClass">
				<c path="Class"><c path="ash.core.NodePool.TNode"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a pool for the given node class.</haxe_doc>
		</new>
		<haxe_doc>* This internal class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead
 * from object creation and garbage collection.
 *
 * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList
 * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool
 * but should not be reused yet. They are then released into the pool by calling the releaseCache method.</haxe_doc>
	</class>
	<class path="ash.core.System" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/core/System.hx">
		<update public="1" set="method" line="69">
			<f a="time">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* After the system is added to the engine, this method is called every frame until the system
     * is removed from the engine. Override this method to add your own functionality.
     *
     * <p>If you need to perform an action outside of the update loop (e.g. you need to change the
     * systems in the engine and you don't want to do it while they're updating) add a listener to
     * the engine's updateComplete signal to be notified when the update loop completes.</p>
     *
     * @param time The duration, in seconds, of the frame.]]></haxe_doc>
		</update>
		<removeFromEngine public="1" set="method" line="54">
			<f a="engine">
				<c path="ash.core.Engine"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called just after the system is removed from the engine, after all calls to the update method.
     * Override this method to add your own functionality.
     *
     * @param engine The engine the system was removed from.</haxe_doc>
		</removeFromEngine>
		<addToEngine public="1" set="method" line="43">
			<f a="engine">
				<c path="ash.core.Engine"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called just after the system is added to the engine, before any calls to the update method.
     * Override this method to add your own functionality.
     *
     * @param engine The engine the system was added to.</haxe_doc>
		</addToEngine>
		<priority public="1">
			<c path="Int"/>
			<haxe_doc>* Used internally to hold the priority of this system within the system list. This is
     * used to order the systems so they are updated in the correct order.</haxe_doc>
		</priority>
		<next public="1">
			<c path="ash.core.System"/>
			<haxe_doc>* Used internally to manage the list of systems within the engine. The next system in the list.</haxe_doc>
		</next>
		<previous public="1">
			<c path="ash.core.System"/>
			<haxe_doc>* Used internally to manage the list of systems within the engine. The previous system in the list.</haxe_doc>
		</previous>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[* The base class for a system.
 *
 * <p>A system is part of the core functionality of the game. After a system is added to the engine, its
 * update method will be called on every frame of the engine. When the system is removed from the engine,
 * the update method is no longer called.</p>
 *
 * <p>The aggregate of all systems in the engine is the functionality of the game, with the update
 * methods of those systems collectively constituting the engine update loop. Systems generally operate on
 * node lists - collections of nodes. Each node contains the components from an entity in the engine
 * that match the node.</p>]]></haxe_doc>
	</class>
	<class path="ash.core.SystemList" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/core/SystemList.hx">
		<iterator public="1" set="method" line="95"><f a=""><t path="Iterator"><c path="ash.core.System"/></t></f></iterator>
		<get public="1" params="TSystem" set="method" line="83"><f a="type">
	<c path="Class"><c path="get.TSystem"/></c>
	<c path="get.TSystem"/>
</f></get>
		<removeAll public="1" set="method" line="71"><f a=""><e path="Void"/></f></removeAll>
		<remove public="1" set="method" line="57"><f a="system">
	<c path="ash.core.System"/>
	<e path="Void"/>
</f></remove>
		<add public="1" set="method" line="17"><f a="system">
	<c path="ash.core.System"/>
	<e path="Void"/>
</f></add>
		<tail public="1" set="null"><c path="ash.core.System"/></tail>
		<head public="1" set="null"><c path="ash.core.System"/></head>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Used internally, this is an ordered list of Systems for use by the engine update loop.</haxe_doc>
	</class>
	<class path="ash.signals.ListenerNode" params="TListener" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/ListenerNode.hx">
		<once public="1"><e path="Bool"/></once>
		<listener public="1"><c path="ash.signals.ListenerNode.TListener"/></listener>
		<next public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNode.TListener"/></c></next>
		<previous public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNode.TListener"/></c></previous>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A node in the list of listeners in a signal.</haxe_doc>
	</class>
	<class path="ash.signals.ListenerNodePool" params="TListener" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/ListenerNodePool.hx">
		<releaseCache public="1" set="method" line="47"><f a=""><e path="Void"/></f></releaseCache>
		<cache public="1" set="method" line="40"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c>
	<e path="Void"/>
</f></cache>
		<dispose public="1" set="method" line="31"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c>
	<e path="Void"/>
</f></dispose>
		<get public="1" set="method" line="16"><f a=""><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></f></get>
		<cacheTail><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></cacheTail>
		<tail><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></tail>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This internal class maintains a pool of deleted listener nodes for reuse by framework. This reduces
 * the overhead from object creation and garbage collection.</haxe_doc>
	</class>
	<class path="ash.signals.SignalBase" params="TListener" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/SignalBase.hx">
		<iterator set="method" line="226"><f a=""><t path="Iterator"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></t></f></iterator>
		<removeAll public="1" set="method" line="211"><f a=""><e path="Void"/></f></removeAll>
		<remove public="1" set="method" line="145"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<e path="Void"/>
</f></remove>
		<addNode set="method" line="114"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c>
	<e path="Void"/>
</f></addNode>
		<addOnce public="1" set="method" line="100"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<e path="Void"/>
</f></addOnce>
		<add public="1" set="method" line="87"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<e path="Void"/>
</f></add>
		<nodeExists get="inline" set="null" line="63"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<e path="Bool"/>
</f></nodeExists>
		<endDispatch set="method" line="41"><f a=""><e path="Void"/></f></endDispatch>
		<startDispatch set="method" line="36"><f a=""><e path="Void"/></f></startDispatch>
		<dispatching><e path="Bool"/></dispatching>
		<toAddTail><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></toAddTail>
		<toAddHead><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></toAddHead>
		<listenerNodePool><c path="ash.signals.ListenerNodePool"><c path="ash.signals.SignalBase.TListener"/></c></listenerNodePool>
		<nodes><c path="ash.ObjectMap">
	<c path="ash.signals.SignalBase.TListener"/>
	<c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c>
</c></nodes>
		<numListeners public="1" set="null"><c path="Int"/></numListeners>
		<tail public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></tail>
		<head public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></head>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The base class for all the signal classes.</haxe_doc>
	</class>
	<class path="ash.signals.Signal0" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/Signal0.hx">
		<extends path="ash.signals.SignalBase"><f a=""><e path="Void"/></f></extends>
		<dispatch public="1" set="method" line="16"><f a=""><e path="Void"/></f></dispatch>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where no parameters are dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.signals.Signal1" params="T1" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/Signal1.hx">
		<extends path="ash.signals.SignalBase"><f a="">
	<c path="ash.signals.Signal1.T1"/>
	<e path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="16"><f a="object">
	<c path="ash.signals.Signal1.T1"/>
	<e path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where one parameter is dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.signals.Signal2" params="T1:T2" file="/usr/lib/haxe/lib/ash/1,5/ash/signals/Signal2.hx">
		<extends path="ash.signals.SignalBase"><f a=":">
	<c path="ash.signals.Signal2.T1"/>
	<c path="ash.signals.Signal2.T2"/>
	<e path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="16"><f a="object1:object2">
	<c path="ash.signals.Signal2.T1"/>
	<c path="ash.signals.Signal2.T2"/>
	<e path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where two parameters are dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.tick.ITickProvider" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/tick/ITickProvider.hx" interface="1">
		<playing public="1" set="null"><e path="Bool"/></playing>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<start public="1" set="method"><f a=""><e path="Void"/></f></start>
		<remove public="1" set="method"><f a="listener">
	<f a="">
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></remove>
		<add public="1" set="method"><f a="listener">
	<f a="">
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></add>
		<haxe_doc>* The interface for a tick provider. A tick provider dispatches a regular update tick
 * to act as the heartbeat for the engine. It has methods to start and stop the tick and
 * to add and remove listeners for the tick.</haxe_doc>
		<meta><m n="interface"/></meta>
	</class>
	<class path="ash.tick.FrameTickProvider" params="" file="/usr/lib/haxe/lib/ash/1,5/ash/tick/FrameTickProvider.hx">
		<implements path="ash.tick.ITickProvider"/>
		<dispatchTick set="method" line="60"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></dispatchTick>
		<stop public="1" set="method" line="54"><f a=""><e path="Void"/></f></stop>
		<start public="1" set="method" line="47"><f a=""><e path="Void"/></f></start>
		<remove public="1" set="method" line="42"><f a="listener">
	<f a="">
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></remove>
		<add public="1" set="method" line="37"><f a="listener">
	<f a="">
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></add>
		<timeAdjustment public="1">
			<c path="Float"/>
			<haxe_doc>* Applies a time adjustment factor to the tick, so you can slow down or speed up the entire engine.
     * The update tick time is multiplied by this value, so a value of 1 will run the engine at the normal rate.</haxe_doc>
		</timeAdjustment>
		<playing public="1" set="null"><e path="Bool"/></playing>
		<signal><c path="ash.signals.Signal1"><c path="Float"/></c></signal>
		<maximumFrameTime><c path="Float"/></maximumFrameTime>
		<previousTime><c path="Float"/></previousTime>
		<displayObject><c path="flash.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="29"><f a="displayObject:?maximumFrameTime">
	<c path="flash.display.DisplayObject"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Uses the enter frame event to provide a frame tick where the frame duration is the time since the previous frame.
 * There is a maximum frame time parameter in the constructor that can be used to limit
 * the longest period a frame can be.</haxe_doc>
	</class>
	<class path="ash.tools.ListIteratingSystem" params="TNode" file="/usr/lib/haxe/lib/ash/1,5/ash/tools/ListIteratingSystem.hx">
		<extends path="ash.core.System"/>
		<update public="1" set="method" line="74" override="1"><f a="time">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<removeFromEngine public="1" set="method" line="61" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></removeFromEngine>
		<addToEngine public="1" set="method" line="46" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></addToEngine>
		<nodeRemovedFunction><f a="">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<e path="Void"/>
</f></nodeRemovedFunction>
		<nodeAddedFunction><f a="">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<e path="Void"/>
</f></nodeAddedFunction>
		<nodeUpdateFunction><f a=":">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<c path="Float"/>
	<e path="Void"/>
</f></nodeUpdateFunction>
		<nodeClass><c path="Class"><c path="ash.tools.ListIteratingSystem.TNode"/></c></nodeClass>
		<nodeList><c path="ash.core.NodeList"><c path="ash.tools.ListIteratingSystem.TNode"/></c></nodeList>
		<new public="1" set="method" line="37"><f a="nodeClass:nodeUpdateFunction:?nodeAddedFunction:?nodeRemovedFunction">
	<c path="Class"><c path="ash.tools.ListIteratingSystem.TNode"/></c>
	<f a=":">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* A useful class for systems which simply iterate over a set of nodes, performing the same action on each node. This
 * class removes the need for a lot of boilerplate code in such systems. Extend this class and pass the node type and
 * a node update method into the constructor. The node update method will be called once per node on the update cycle
 * with the node instance and the frame time as parameters. e.g.
 *
 * <code>package;
 * class MySystem extends ListIteratingSystem<MyNode>
 * {
 *     public function new()
 *     {
 *         super(MyNode, updateNode);
 *     }
 *
 *     private function updateNode(node:MyNode, time:Float):Void
 *     {
 *         // process the node here
 *     }
 * }
 * </code>]]></haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<meta><m n="interface"/></meta>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"><meta><m n="interface"/></meta></class>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.spritesheet.AnimatedSprite" params="" file="/usr/lib/haxe/lib/spritesheet/1,11/com/eclecticdesignstudio/spritesheet/AnimatedSprite.hx">
		<extends path="flash.display.Sprite"/>
		<updateBehavior set="method" line="178"><f a="behavior:?restart">
	<c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></updateBehavior>
		<update public="1" set="method" line="128"><f a="deltaTime">
	<c path="Int"/>
	<e path="Void"/>
</f></update>
		<showBehaviors public="1" set="method" line="109"><f a="behaviors">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></showBehaviors>
		<showBehavior public="1" set="method" line="100"><f a="behavior:?restart">
	<d/>
	<e path="Bool"/>
	<e path="Void"/>
</f></showBehavior>
		<resolveBehavior set="method" line="79"><f a="behavior">
	<d/>
	<c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/>
</f></resolveBehavior>
		<queueBehavior public="1" set="method" line="62"><f a="behavior">
	<d/>
	<e path="Void"/>
</f></queueBehavior>
		<getFrameData public="1" set="method" line="47"><f a="index">
	<c path="Int"/>
	<d/>
</f></getFrameData>
		<timeElapsed><c path="Int"/></timeElapsed>
		<loopTime><c path="Int"/></loopTime>
		<behavior><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></behavior>
		<behaviorQueue><c path="Array"><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></c></behaviorQueue>
		<behaviorComplete><e path="Bool"/></behaviorComplete>
		<spritesheet public="1"><c path="com.eclecticdesignstudio.spritesheet.Spritesheet"/></spritesheet>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<currentFrameIndex public="1"><c path="Int"/></currentFrameIndex>
		<currentBehavior public="1"><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></currentBehavior>
		<bitmap public="1"><c path="flash.display.Bitmap"/></bitmap>
		<new public="1" set="method" line="33"><f a="spritesheet:?smoothing">
	<c path="com.eclecticdesignstudio.spritesheet.Spritesheet"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.spritesheet.Spritesheet" params="" file="/usr/lib/haxe/lib/spritesheet/1,11/com/eclecticdesignstudio/spritesheet/Spritesheet.hx">
		<updateImage public="1" set="method" line="190"><f a="image:?imageAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></updateImage>
		<merge public="1" set="method" line="142"><f a="spritesheet">
	<c path="com.eclecticdesignstudio.spritesheet.Spritesheet"/>
	<c path="Array"><c path="Int"/></c>
</f></merge>
		<getFrames public="1" set="method" line="135"><f a=""><c path="Array"><c path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame"/></c></f></getFrames>
		<getFrameIDs public="1" set="method" line="120"><f a=""><c path="Array"><c path="Int"/></c></f></getFrameIDs>
		<getFrame public="1" set="method" line="105"><f a="index:?autoGenerate">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame"/>
</f></getFrame>
		<generateBitmap public="1" set="method" line="84"><f a="index">
	<c path="Int"/>
	<e path="Void"/>
</f></generateBitmap>
		<generateBitmaps public="1" set="method" line="73"><f a=""><e path="Void"/></f></generateBitmaps>
		<addFrame public="1" set="method" line="65"><f a="frame">
	<c path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame"/>
	<e path="Void"/>
</f></addFrame>
		<addBehavior public="1" set="method" line="58"><f a="behavior">
	<c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/>
	<e path="Void"/>
</f></addBehavior>
		<sourceImageAlpha><c path="flash.display.BitmapData"/></sourceImageAlpha>
		<sourceImage><c path="flash.display.BitmapData"/></sourceImage>
		<frames><c path="Array"><c path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame"/></c></frames>
		<totalFrames public="1"><c path="Int"/></totalFrames>
		<name public="1"><c path="String"/></name>
		<behaviors public="1"><c path="Hash"><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></c></behaviors>
		<new public="1" set="method" line="28"><f a="?image:?frames:?behaviors:?imageAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="Array"><c path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame"/></c>
	<c path="Hash"><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></c>
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.spritesheet.data.BehaviorData" params="" file="/usr/lib/haxe/lib/spritesheet/1,11/com/eclecticdesignstudio/spritesheet/data/BehaviorData.hx">
		<uniqueID line="23" static="1"><c path="Int"/></uniqueID>
		<clone public="1" set="method" line="58"><f a=""><c path="com.eclecticdesignstudio.spritesheet.data.BehaviorData"/></f></clone>
		<originY public="1"><c path="Float"/></originY>
		<originX public="1"><c path="Float"/></originX>
		<name public="1"><c path="String"/></name>
		<loop public="1"><e path="Bool"/></loop>
		<frames public="1"><c path="Array"><c path="Int"/></c></frames>
		<frameRate public="1"><c path="Int"/></frameRate>
		<frameData public="1"><c path="Array"><d/></c></frameData>
		<new public="1" set="method" line="26"><f a="?name:?frames:?loop:?frameRate:?originX:?originY">
	<c path="String"/>
	<c path="Array"><c path="Int"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.spritesheet.data.SpritesheetFrame" params="" file="/usr/lib/haxe/lib/spritesheet/1,11/com/eclecticdesignstudio/spritesheet/data/SpritesheetFrame.hx">
		<y public="1"><c path="Int"/></y>
		<x public="1"><c path="Int"/></x>
		<width public="1"><c path="Int"/></width>
		<offsetY public="1"><c path="Int"/></offsetY>
		<offsetX public="1"><c path="Int"/></offsetX>
		<height public="1"><c path="Int"/></height>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method" line="24"><f a="?x:?y:?width:?height:?offsetX:?offsetY">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Joshua Granick</haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.spritesheet.importers.BitmapImporter" params="" file="/usr/lib/haxe/lib/spritesheet/1,11/com/eclecticdesignstudio/spritesheet/importers/BitmapImporter.hx"><create public="1" set="method" line="16" static="1"><f a="bitmapData:columns:rows:tileWidth:tileHeight:?adjustLength:?scale">
	<c path="flash.display.BitmapData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="com.eclecticdesignstudio.spritesheet.Spritesheet"/>
</f></create></class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1" set="method">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,5/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1" set="method">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"><meta><m n="interface"/></meta></class>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="/usr/lib/haxe/std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1" set="null">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1" set="null">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1" set="method">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><e path="Bool"/></available>
		<marshallExceptions public="1" static="1"><e path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="/usr/lib/haxe/std/flash/filters/GlowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<strength public="1"><c path="Float"/></strength>
		<quality public="1"><c path="Int"/></quality>
		<knockout public="1"><e path="Bool"/></knockout>
		<inner public="1"><e path="Bool"/></inner>
		<color public="1"><t path="UInt"/></color>
		<blurY public="1"><c path="Float"/></blurY>
		<blurX public="1"><c path="Float"/></blurX>
		<alpha public="1"><c path="Float"/></alpha>
		<new public="1" set="method"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout">
	<t path="UInt"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1" set="method">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1" set="method">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" set="method" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<loadPCMFromByteArray public="1" set="method">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1" set="method">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<extract public="1" set="method">
			<f a="target:length:?startPosition">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</extract>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" set="null"><c path="Float"/></length>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1" set="method">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1" set="method">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.Font" params="" file="/usr/lib/haxe/std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="/usr/lib/haxe/std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="/usr/lib/haxe/std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1" set="null">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<meta><m n="interface"/></meta>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<meta><m n="interface"/></meta>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<e path="Void"/>
</f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<e path="Void"/>
</f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/lib/nme/3,5,5/flash/utils/CompressionAlgorithm.hx">
		<ZLIB/>
		<LZMA/>
		<DEFLATE/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<global public="1" set="null"><e path="Bool"/></global>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":native"><e>RegExp</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.utils.TypedDictionary" params="K:T" file="/usr/lib/haxe/std/flash/utils/TypedDictionary.hx">
		<extends path="flash.utils.Dictionary"/>
		<iterator public="1" set="method" line="52"><f a=""><t path="Iterator"><c path="flash.utils.TypedDictionary.K"/></t></f></iterator>
		<keys public="1" get="inline" set="null" line="48"><f a=""><c path="Array"><c path="flash.utils.TypedDictionary.K"/></c></f></keys>
		<delete public="1" get="inline" set="null" line="44"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Void"/>
</f></delete>
		<exists public="1" get="inline" set="null" line="40"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Bool"/>
</f></exists>
		<set public="1" get="inline" set="null" line="36"><f a="k:v">
	<c path="flash.utils.TypedDictionary.K"/>
	<c path="flash.utils.TypedDictionary.T"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="32"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<t path="Null"><c path="flash.utils.TypedDictionary.T"/></t>
</f></get>
		<new public="1" set="method" line="30"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This is a typed version of the Flash9 Dictionary class.</haxe_doc>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="format.display.FrameLabel" params="" file="/usr/lib/haxe/lib/nme/3,5,5/format/display/FrameLabel.hx">
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method" line="11"><f a="frame:name">
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,5,5/format/display/MovieClip.hx">
		<extends path="flash.display.Sprite"/>
		<unflatten public="1" set="method" line="97"><f a=""><e path="Void"/></f></unflatten>
		<stop public="1" set="method" line="90"><f a=""><e path="Void"/></f></stop>
		<prevFrame public="1" set="method" line="83"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method" line="76"><f a=""><e path="Void"/></f></play>
		<nextFrame public="1" set="method" line="62"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method" line="55"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method" line="48"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<flatten public="1" set="method" line="41"><f a=""><e path="Void"/></f></flatten>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentLabels public="1" set="null"><c path="Array"><c path="format.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Base class for MovieClip-related format libraries
 * 
 * Cannot use flash.display.MovieClip, because it does
 * not allow the addition for frames or frame labels at
 * runtime, asynchronously</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Resource" params="" file="/usr/lib/haxe/std/flash/_std/haxe/Resource.hx">
		<content static="1"><c path="Array"><a><name><c path="String"/></name></a></c></content>
		<listNames public="1" set="method" line="58" static="1"><f a=""><c path="Array"><c path="String"/></c></f></listNames>
		<getString public="1" set="method" line="65" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<getBytes public="1" set="method" line="70" static="1"><f a="name">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<resolve set="method" line="75" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
</f></resolve>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>Elements return by [Stack] methods.</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="/usr/lib/haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="97" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="131" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="140" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="167" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
	</class>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/lib/nme/3,5,5/haxe/Timer.hx">
		<delay public="1" set="method" line="54" static="1">
			<f a="f:time_ms">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>This will delay the call to [f] for the given time. [f] will only be called once.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="68" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measure the time it takes to execute the function [f] and trace it. Returns the value returned by [f].</haxe_doc>
		</measure>
		<stamp public="1" set="method" line="78" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the most precise timestamp, in seconds. The value itself might differ depending on platforms, only differences between two values make sense.</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>This is the [run()] method that is called when the Timer executes. It can be either overriden in subclasses or directly rebinded with another function-value.</haxe_doc>
		</run>
		<stop public="1" set="method" line="32">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Stop the timer definitely.</haxe_doc>
		</stop>
		<id><t path="Null"><c path="Int"/></t></id>
		<new public="1" set="method" line="16">
			<f a="time_ms">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Create a new timer that will run every [time_ms] (in milliseconds).</haxe_doc>
		</new>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="haxe.rtti.Path" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="String"/></typedef>
	<typedef path="haxe.rtti.Platforms" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="List"><c path="String"/></c></typedef>
	<enum path="haxe.rtti.CType" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx">
		<CUnknown/>
		<CTypedef a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CTypedef>
		<CFunction a="args:ret">
			<c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.rtti.CType"/>
		</CFunction>
		<CEnum a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CEnum>
		<CDynamic a="?t"><e path="haxe.rtti.CType"/></CDynamic>
		<CClass a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CClass>
		<CAnonymous a="fields"><c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<name><c path="String"/></name>
</a></c></CAnonymous>
	</enum>
	<typedef path="haxe.rtti.PathParams" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<path><t path="haxe.rtti.Path"/></path>
	<params><c path="List"><e path="haxe.rtti.CType"/></c></params>
</a></typedef>
	<typedef path="haxe.rtti.TypeParams" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="Array"><c path="String"/></c></typedef>
	<enum path="haxe.rtti.Rights" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<RNormal/>
		<RNo/>
		<RMethod/>
		<RInline/>
		<RDynamic/>
		<RCall a="m"><c path="String"/></RCall>
	</enum>
	<typedef path="haxe.rtti.ClassField" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<type><e path="haxe.rtti.CType"/></type>
	<set><e path="haxe.rtti.Rights"/></set>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<name><c path="String"/></name>
	<isPublic><e path="Bool"/></isPublic>
	<isOverride><e path="Bool"/></isOverride>
	<get><e path="haxe.rtti.Rights"/></get>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.TypeInfos" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.Classdef" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<tdynamic><t path="Null"><e path="haxe.rtti.CType"/></t></tdynamic>
	<superClass><t path="haxe.rtti.PathParams"/></superClass>
	<statics><c path="List"><t path="haxe.rtti.ClassField"/></c></statics>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="List"><t path="haxe.rtti.PathParams"/></c></interfaces>
	<fields><c path="List"><t path="haxe.rtti.ClassField"/></c></fields>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.EnumField" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<name><c path="String"/></name>
	<doc><c path="String"/></doc>
	<args><t path="Null"><c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c></t></args>
</a></typedef>
	<typedef path="haxe.rtti.Enumdef" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<doc><c path="String"/></doc>
	<constructors><c path="List"><t path="haxe.rtti.EnumField"/></c></constructors>
</a></typedef>
	<typedef path="haxe.rtti.Typedef" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<types><c path="Hash"><e path="haxe.rtti.CType"/></c></types>
	<type><e path="haxe.rtti.CType"/></type>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<doc><c path="String"/></doc>
</a></typedef>
	<enum path="haxe.rtti.TypeTree" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<TTypedecl a="t"><t path="haxe.rtti.Typedef"/></TTypedecl>
		<TPackage a="name:full:subs">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		</TPackage>
		<TEnumdecl a="e"><t path="haxe.rtti.Enumdef"/></TEnumdecl>
		<TClassdecl a="c"><t path="haxe.rtti.Classdef"/></TClassdecl>
	</enum>
	<typedef path="haxe.rtti.TypeRoot" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="Array"><e path="haxe.rtti.TypeTree"/></c></typedef>
	<class path="haxe.rtti.TypeApi" params="" file="/usr/lib/haxe/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<typeInfos public="1" set="method" line="116" static="1"><f a="t">
	<e path="haxe.rtti.TypeTree"/>
	<t path="haxe.rtti.TypeInfos"/>
</f></typeInfos>
		<isVar public="1" set="method" line="127" static="1"><f a="t">
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
</f></isVar>
		<leq params="T" set="method" line="134" static="1"><f a="f:l1:l2">
	<f a=":">
		<c path="leq.T"/>
		<c path="leq.T"/>
		<e path="Bool"/>
	</f>
	<c path="List"><c path="leq.T"/></c>
	<c path="List"><c path="leq.T"/></c>
	<e path="Bool"/>
</f></leq>
		<rightsEq public="1" set="method" line="148" static="1"><f a="r1:r2">
	<e path="haxe.rtti.Rights"/>
	<e path="haxe.rtti.Rights"/>
	<e path="Bool"/>
</f></rightsEq>
		<typeEq public="1" set="method" line="163" static="1"><f a="t1:t2">
	<e path="haxe.rtti.CType"/>
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
</f></typeEq>
		<fieldEq public="1" set="method" line="212" static="1"><f a="f1:f2">
	<t path="haxe.rtti.ClassField"/>
	<t path="haxe.rtti.ClassField"/>
	<e path="Bool"/>
</f></fieldEq>
		<constructorEq public="1" set="method" line="232" static="1"><f a="c1:c2">
	<t path="haxe.rtti.EnumField"/>
	<t path="haxe.rtti.EnumField"/>
	<e path="Bool"/>
</f></constructorEq>
	</class>
	<class path="haxe.rtti.Meta" params="" file="/usr/lib/haxe/std/haxe/rtti/Meta.hx">
		<getType public="1" set="method" line="35" static="1">
			<f a="t">
				<d/>
				<d><c path="Array"><d/></c></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given type (class or enum)</haxe_doc>
		</getType>
		<getStatics public="1" set="method" line="47" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getStatics>
		<getFields public="1" set="method" line="59" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class static fields</haxe_doc>
		</getFields>
		<haxe_doc>An api to access classes and enums metadata at runtime.</haxe_doc>
	</class>
	<typedef path="mconsole._Console.CallStack" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Console.hx" private="1" module="mconsole.Console"><c path="haxe.Stack"/></typedef>
	<typedef path="mconsole._Console.StringMap" params="T" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Console.hx" private="1" module="mconsole.Console"><c path="Hash"><c path="mconsole._Console.StringMap.T"/></c></typedef>
	<class path="mconsole.PrinterBase" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Printer.hx" module="mconsole.Printer">
		<printLine set="method" line="153">
			<f a="color:line:pos">
				<e path="mconsole.ConsoleColor"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Abstract implementation.</haxe_doc>
		</printLine>
		<print public="1" set="method" line="88">
			<f a="level:params:indent:pos">
				<e path="mconsole.LogLevel"/>
				<c path="Array"><d/></c>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print an array of values to the console at a LogLevel and indent level.

	@param	level	The level of the message to print
	@param	params	An array of values to print
	@param	indent	The indent level of the message to be printed.
	@param	pos		The position where the message was printed.</haxe_doc>
		</print>
		<lineNumber>
			<c path="String"/>
			<haxe_doc>The previous log's line number.</haxe_doc>
		</lineNumber>
		<position>
			<c path="String"/>
			<haxe_doc>The previous log's position.</haxe_doc>
		</position>
		<printLineNumbers public="1">
			<e path="Bool"/>
			<haxe_doc>When the printing line changes print the line number before the message.</haxe_doc>
		</printLineNumbers>
		<printPosition public="1">
			<e path="Bool"/>
			<haxe_doc>When the printing position changes (position is className.methodName), 
	print the new position before the message.</haxe_doc>
		</printPosition>
		<new set="method" line="74"><f a=""><e path="Void"/></f></new>
		<haxe_doc>A base ConsolePrinter implementation for functionality shared by 
FlashConsolePrinter, HTMLConsolePrinter and CommandLineConsolePrinter.</haxe_doc>
	</class>
	<class path="mconsole.Printer" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Printer.hx" interface="1">
		<print public="1" set="method">
			<f a="level:params:indent:pos">
				<e path="mconsole.LogLevel"/>
				<c path="Array"><d/></c>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print an array of values to the console at a LogLevel and indent level.

	@param	level	The level of the message to print
	@param	params	An array of values to print
	@param	indent	The indent level of the message to be printed.
	@param	pos		The position where the message was printed.</haxe_doc>
		</print>
		<haxe_doc>A ConsolePrinter is responsible for printing the output of the Console. 
Messages can be printed at different LogLevels and at different 
indentations. Implementations can also define activate/deactivate behavior 
when they are set/unset as the current console printer using 
Console.setPrinter()</haxe_doc>
		<meta><m n="interface"/></meta>
	</class>
	<class path="mconsole.ConsoleView" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/ConsoleView.hx">
		<extends path="mconsole.PrinterBase"/>
		<implements path="mconsole.Printer"/>
		<remove public="1" set="method" line="313"><f a=""><e path="Void"/></f></remove>
		<attach public="1" set="method" line="308"><f a=""><e path="Void"/></f></attach>
		<printLine set="method" line="288" override="1">
			<f a="color:line:pos">
				<e path="mconsole.ConsoleColor"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add a single formatted line of output to the log panel. Scroll to the bottom 
	of the output if atBottom is true.</haxe_doc>
		</printLine>
		<updateScroll set="method" line="279">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Scroll to the bottom of output if atBottom is true.</haxe_doc>
		</updateScroll>
		<textScrolled set="method" line="271">
			<f a="_">
				<unknown/>
				<e path="Void"/>
			</f>
			<haxe_doc>When the log output scrolls, evaluate atBottom.</haxe_doc>
		</textScrolled>
		<resize set="method" line="255">
			<f a="_">
				<unknown/>
				<e path="Void"/>
			</f>
			<haxe_doc>Resize the log panel when the stage resizes.</haxe_doc>
		</resize>
		<atBottom>
			<e path="Bool"/>
			<haxe_doc>Is the panel currently scrolled to the bottom? When true, new messages will 
	automatically scroll to the bottom.</haxe_doc>
		</atBottom>
		<textField>
			<c path="flash.text.TextField"/>
			<haxe_doc>The log output text field.</haxe_doc>
		</textField>
		<background>
			<c path="flash.display.Sprite"/>
			<haxe_doc>The background color of the log panel.</haxe_doc>
		</background>
		<sprite public="1" set="null">
			<c path="flash.display.Sprite"/>
			<haxe_doc>The sprite container for the log panel</haxe_doc>
		</sprite>
		<new public="1" set="method" line="208"><f a=""><e path="Void"/></f></new>
		<haxe_doc>A Printer that prints formatted logs to a Flash TextField.</haxe_doc>
	</class>
	<class path="mconsole.Console" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Console.hx">
		<defaultPrinter public="1" line="80" static="1">
			<c path="mconsole.ConsoleView"/>
			<haxe_doc>The default console printer.</haxe_doc>
		</defaultPrinter>
		<printers line="89" static="1">
			<c path="Array"><c path="mconsole.Printer"/></c>
			<haxe_doc>The ConsolePrinters to print output to.</haxe_doc>
		</printers>
		<groupDepth line="95" static="1">
			<c path="Int"/>
			<haxe_doc>The current group depth, incremented when group(name) is called, and 
		decremented when groupEnd() is called.</haxe_doc>
		</groupDepth>
		<times line="100" static="1">
			<t path="mconsole._Console.StringMap"><c path="Float"/></t>
			<haxe_doc>A map of named timestamps.</haxe_doc>
		</times>
		<counts line="105" static="1">
			<t path="mconsole._Console.StringMap"><c path="Int"/></t>
			<haxe_doc>A map of counters by a unique posInfo identifier.</haxe_doc>
		</counts>
		<previousTrace static="1">
			<d/>
			<haxe_doc>The previous value of haxe.Log.trace if redirectTraces has been called, 
		or null if it has not.</haxe_doc>
		</previousTrace>
		<running line="116" static="1">
			<e path="Bool"/>
			<haxe_doc>Is the console currently active?</haxe_doc>
		</running>
		<BRIDGE line="127" static="1">
			<c path="String"/>
			<haxe_doc>Magic: The only way to get Haxe XML objects to print nicely in the 
		WebKit console is if they are HTMLDom objects. So we log XML as:
			{__xml__:true, xml:xml.toString()}
		We call this "bridge" function via external interface, which checks for 
		__xml__ == true, and parses XML into a DOM using a DOMParser if it is.</haxe_doc>
		</BRIDGE>
		<CREATE_BRIDGE_SCRIPT line="132" static="1">
			<c path="String"/>
			<haxe_doc>Eval'd to create the bridge.</haxe_doc>
		</CREATE_BRIDGE_SCRIPT>
		<REMOVE_BRIDGE_SCRIPT line="145" static="1">
			<c path="String"/>
			<haxe_doc>Eval'd to remove the bridge.</haxe_doc>
		</REMOVE_BRIDGE_SCRIPT>
		<start public="1" set="method" line="157" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Starts the console, redirecting haxe.Log.trace and adding a default 
		printer if WebKit is not available.

		The trace method accepts a variable number of arguments which are 
		passed to the console. If the first argument is a string that matches a 
		log level (log, info, warn...) then the trace is logged at that level.</haxe_doc>
		</start>
		<stop public="1" set="method" line="185" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Restores the console to an inactive state.</haxe_doc>
		</stop>
		<addPrinter public="1" set="method" line="213" static="1">
			<f a="printer">
				<c path="mconsole.Printer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add a console printer.</haxe_doc>
		</addPrinter>
		<removePrinter public="1" set="method" line="222" static="1">
			<f a="printer">
				<c path="mconsole.Printer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Remove a console printer.</haxe_doc>
		</removePrinter>
		<haxeTrace set="method" line="231" static="1">
			<f a="value:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>The method called by Haxe trace. Checks if the first parameter matches 
		a log level, and forwards the log to the appropriate handler.</haxe_doc>
		</haxeTrace>
		<print get="inline" set="null" line="255" static="1">
			<f a="level:params:pos">
				<e path="mconsole.LogLevel"/>
				<c path="Array"><d/></c>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print a message to each of the printers.</haxe_doc>
		</print>
		<log public="1" get="inline" set="null" line="263" static="1">
			<f a="message:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the message.</haxe_doc>
		</log>
		<info public="1" get="inline" set="null" line="272" static="1">
			<f a="message:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the message.</haxe_doc>
		</info>
		<debug public="1" get="inline" set="null" line="281" static="1">
			<f a="message:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the message.</haxe_doc>
		</debug>
		<warn public="1" get="inline" set="null" line="290" static="1">
			<f a="message:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs a "warning" icon followed by a color-coded message.</haxe_doc>
		</warn>
		<error public="1" get="inline" set="null" line="299" static="1">
			<f a="message:?stack:?pos">
				<d/>
				<c path="Array"><e path="haxe.StackItem"/></c>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs an "error" icon followed by a color-coded message.</haxe_doc>
		</error>
		<trace public="1" get="inline" set="null" line="323" static="1">
			<f a="?pos">
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs a stack trace at the moment the function is called. The stack 
		trace lists the functions on the call stack (functions that have been 
		called and have not yet finished executing and returned) and the values 
		of any arguments passed to those functions.</haxe_doc>
		</trace>
		<assert public="1" get="inline" set="null" line="343" static="1">
			<f a="expression:message:?pos">
				<e path="Bool"/>
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>If expression evaluates to false, logs the message.</haxe_doc>
		</assert>
		<count public="1" get="inline" set="null" line="359" static="1">
			<f a="title:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the number of times this line of code has executed, and an 
		optional title.</haxe_doc>
		</count>
		<group public="1" get="inline" set="null" line="373" static="1">
			<f a="message:?pos">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the message object and begins an indented block for further 
		log entries.</haxe_doc>
		</group>
		<groupEnd public="1" get="inline" set="null" line="384" static="1">
			<f a="?pos">
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Ends an indented block of log entries.</haxe_doc>
		</groupEnd>
		<time public="1" get="inline" set="null" line="393" static="1">
			<f a="name:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Starts a timer and gives it a name.</haxe_doc>
		</time>
		<timeEnd public="1" get="inline" set="null" line="403" static="1">
			<f a="name:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Logs the time since Console.time(name) was called, and restarts the timer.</haxe_doc>
		</timeEnd>
		<markTimeline public="1" get="inline" set="null" line="419" static="1">
			<f a="label:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a label to the timeline view marking when the point when the 
		method was called.</haxe_doc>
		</markTimeline>
		<profile public="1" get="inline" set="null" line="432" static="1">
			<f a="?title:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Begins profiling JavaScripttracking the number of times each function 
		is called, the time spent in that function, and the time spent in 
		nested groups of functions. If a title is provided, the profile is 
		named.</haxe_doc>
		</profile>
		<profileEnd public="1" get="inline" set="null" line="446" static="1">
			<f a="?title:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Ends one or more JavaScript profiles. If a title is provided and a 
		running profile has a matching title, only the current run of that 
		profile is ended. Otherwise, the current run of all profiles is ended.</haxe_doc>
		</profileEnd>
		<enterDebugger public="1" get="inline" set="null" line="458" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Inserts a breakpoint at the calling position.</haxe_doc>
		</enterDebugger>
		<dirxml line="472" static="1">
			<c path="String"/>
			<haxe_doc>The console method used to print xml.</haxe_doc>
		</dirxml>
		<hasConsole line="477" static="1">
			<e path="Bool"/>
			<haxe_doc>Is the WebKit console API available?</haxe_doc>
		</hasConsole>
		<detectConsole set="method" line="483" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Detects if the WebKit console API is available, either natively in 
		JavaScript or via ExternalConnection in Flash.</haxe_doc>
		</detectConsole>
		<callConsole get="inline" set="null" line="500" static="1">
			<f a="method:params">
				<c path="String"/>
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>Calls a method on the WebKit console API, either directly in JS or via 
		ExternalInterface in Flash running in a WebKit browser.</haxe_doc>
		</callConsole>
		<toConsoleValues set="method" line="524" static="1">
			<f a="params">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Convert parameters for console methods into 'native' objects that will 
		print.</haxe_doc>
		</toConsoleValues>
		<toConsoleValue set="method" line="534" static="1">
			<f a="value">
				<d/>
				<d/>
			</f>
			<haxe_doc>Converts a value into the anything that will print nicely in the 
		console.</haxe_doc>
		</toConsoleValue>
		<haxe_doc>This console implementation assumes the availability of the WebKit console. 
	We inline calls to the native API rather than simply creating an extern so 
	we can add additional console methods (such as enterDebugger). This also 
	means we can convert some Haxe structures (XML for example) into something 
	more readable in the console.

	In flash, we call the WebKit console API through ExternalInterface.</haxe_doc>
	</class>
	<enum path="mconsole.LogLevel" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/LogLevel.hx">
		<warn><haxe_doc>Logs indicating unexpected but not fatal program behavior.</haxe_doc></warn>
		<log><haxe_doc>A generic log level.</haxe_doc></log>
		<info><haxe_doc>Logs important for following the current state of a program.</haxe_doc></info>
		<error><haxe_doc>Logs indicating a program error.</haxe_doc></error>
		<debug><haxe_doc>Logs important for debugging problems with a program.</haxe_doc></debug>
		<haxe_doc>Log levels are a way for developers to group and filter log messages depending 
on the kind of information being logged.</haxe_doc>
	</enum>
	<enum path="mconsole.ConsoleColor" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/Printer.hx" module="mconsole.Printer">
		<yellow/>
		<white/>
		<red/>
		<none/>
		<green/>
		<blue/>
		<haxe_doc>An enum defining possible colors for console output.</haxe_doc>
	</enum>
	<typedef path="mconsole._StackHelper.CallStack" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/StackHelper.hx" private="1" module="mconsole.StackHelper"><c path="haxe.Stack"/></typedef>
	<typedef path="mconsole._StackHelper.StringMap" params="T" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/StackHelper.hx" private="1" module="mconsole.StackHelper"><c path="Hash"><c path="mconsole._StackHelper.StringMap.T"/></c></typedef>
	<class path="mconsole.StackHelper" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/StackHelper.hx">
		<filters line="39" static="1"><t path="mconsole._StackHelper.StringMap"><e path="Bool"/></t></filters>
		<createFilters set="method" line="41" static="1"><f a=""><t path="mconsole._StackHelper.StringMap"><e path="Bool"/></t></f></createFilters>
		<toString public="1" set="method" line="48" static="1"><f a="stack">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="String"/>
</f></toString>
		<haxe_doc>A utility class for formatting stack traces as strings.</haxe_doc>
	</class>
	<class path="mconsole.StackItemHelper" params="" file="/usr/lib/haxe/lib/mconsole/1,3,0/mconsole/StackHelper.hx" module="mconsole.StackHelper">
		<toString public="1" set="method" line="83" static="1"><f a="item:?isFirst">
	<e path="haxe.StackItem"/>
	<e path="Bool"/>
	<c path="String"/>
</f></toString>
		<haxe_doc>A utility class for formatting stack items as strings.</haxe_doc>
	</class>
	<class path="mcore.exception.Exception" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/exception/Exception.hx">
		<getStackTrace public="1" set="method" line="104" static="1">
			<f a="source">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a formatted list of the current exception stack

	@param source		an originating cause (such as a native flash error)
	@return formatting string of stack items</haxe_doc>
		</getStackTrace>
		<toString public="1" set="method" line="84">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[Returns a string representation of this exception.
	
	Format: 
	<pre>
	<type>: <message> at <className>#<methodName> (<lineNumber>) Caused by: <cause>
	</pre>
   
	@return string representation of exception adhering to format above]]></haxe_doc>
		</toString>
		<info public="1" set="null"><t path="haxe.PosInfos"/></info>
		<cause public="1" set="null"><d/></cause>
		<get_message set="method" line="57"><f a=""><c path="String"/></f></get_message>
		<message public="1" get="get_message" set="null"><c path="String"/></message>
		<get_name set="method" line="54"><f a=""><c path="String"/></f></get_name>
		<name public="1" get="get_name" set="null"><c path="String"/></name>
		<new public="1" set="method" line="66">
			<f a="?message:?cause:?info">
				<c path="String"/>
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@param message  an optional message helping to describe the exception
	@param cause    the exception which caused this one, if any. May be a native platform exception.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The base class for other exceptions.

When an error is detected, or a platform specific exception is caught, an instance
of Exception can be raised better describing the issue. This allows consistent
and targeted capturing of exceptions further down the call stack.

<pre>
try
{
	throw new Exception("something bad happened");
}
catch(e:Exception)
{
	trace(e.toString());
	//outputs "Exception: something bad happened at foo.Bar#doSomething(123)"
}
</pre>]]></haxe_doc>
	</class>
	<class path="mcore.exception.ArgumentException" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/exception/ArgumentException.hx">
		<extends path="mcore.exception.Exception"/>
		<new public="1" set="method" line="34"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>To be raised anywhere in which an argument provided is not what was expected.

@see mcore.exception.Exception</haxe_doc>
	</class>
	<typedef path="mcore.exception._Exception.CallStack" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/exception/Exception.hx" private="1" module="mcore.exception.Exception"><c path="haxe.Stack"/></typedef>
	<class path="mcore.util.Arrays" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/util/Arrays.hx">
		<toString public="1" params="T" get="inline" set="null" line="36" static="1">
			<f a="source">
				<c path="Array"><c path="toString.T"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Normalises toString() output between platforms
	For example: ["a", "b", "c"] becomes "a,b,c"
	Note: in neko and cpp array.toString includes the '[]' and has space between each value.
	Where as in js/flash it doesnt.

	@param source 	The source array to convert to string;
	@return string in format "a,b,c"</haxe_doc>
		</toString>
		<shuffle public="1" params="T" set="method" line="48" static="1">
			<f a="source">
				<c path="Array"><c path="shuffle.T"/></c>
				<c path="Array"><c path="shuffle.T"/></c>
			</f>
			<haxe_doc>Returns a copy of the source array, with its elements randomly reordered</haxe_doc>
		</shuffle>
		<lastItem public="1" params="T" get="inline" set="null" line="60" static="1">
			<f a="source">
				<c path="Array"><c path="lastItem.T"/></c>
				<c path="lastItem.T"/>
			</f>
			<haxe_doc>Convenience method to get the last item in an array.</haxe_doc>
		</lastItem>
	</class>
	<class path="mcore.util.Reflection" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/util/Reflection.hx">
		<setProperty public="1" set="method" line="50" static="1">
			<f a="object:property:value">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>Sets the value of a property, calling it's setter if present and of 
	the format set_property (haxe 208 only).

	For Haxe 209 or greater use Reflect.setProperty
	
	@param object		the object to set the property on
	@param property 	the property to set
	@param value 		the new value of the property
	@return the new value of the property</haxe_doc>
		</setProperty>
		<hasProperty public="1" set="method" line="64" static="1">
			<f a="object:property">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>A convenience method for checking if a class instance has a property.
	@param object 		the class instance to check
	@param property 	the property to check for
	@return true if the instance implements the property, false if not.</haxe_doc>
		</hasProperty>
		<getFields public="1" set="method" line="77" static="1">
			<f a="object">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the instance fields of an object if it is a class instance, 
	or else it's reflected fields.
	
	@param object 		the object to reflect
	@return instance or reflected fields</haxe_doc>
		</getFields>
		<here public="1" set="method" line="88" static="1">
			<f a="?info">
				<t path="haxe.PosInfos"/>
				<t path="haxe.PosInfos"/>
			</f>
			<haxe_doc>Returns information about the location this method is called.</haxe_doc>
		</here>
		<callMethod public="1" set="method" line="102" static="1">
			<f a="o:func:?args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<unknown/>
			</f>
			<haxe_doc>Wraps Reflect.callMethod to support optional arguments in neko
	
	@param o 	the given object to reflect on
	@param func reference to the function to call on (i.e. Reflect.field(o, "func");)
	@param args 	optional array of arguments
	@throws ArgumentException is Reflect.callMethod fails</haxe_doc>
		</callMethod>
		<haxe_doc>Utility methods for working with reflection.</haxe_doc>
	</class>
	<class path="mcore.util.Types" params="" file="/usr/lib/haxe/lib/minject/1,2,0/mcore/util/Types.hx">
		<isSubClassOf public="1" set="method" line="41" static="1">
			<f a="object:type">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Checks if an object is an instance of, or instance of a subclass of 
	a given type.
	
	@param object 	the instance to check
	@param type 	the type to compare against
	@return true if object is instance of type or subclass else false</haxe_doc>
		</isSubClassOf>
		<createInstance public="1" params="T" set="method" line="54" static="1">
			<f a="forClass:?args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Wraps Type.createInstance to support optional constructor arguments in neko
	
	@param forClass 	the class type to instanciate
	@param args 	optional array of arguments
	@return instance of type
	@throws ArgumentException is Type.createInstance fails</haxe_doc>
		</createInstance>
		<haxe_doc>Utility methods for working with types.</haxe_doc>
	</class>
	<class path="mdata.Dictionary" params="K:V" file="/usr/lib/haxe/lib/minject/1,2,0/mdata/Dictionary.hx">
		<toString public="1" set="method" line="215">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the string representation of the keys and values in this Dictionary.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="200">
			<f a=""><t path="Iterator"><c path="mdata.Dictionary.V"/></t></f>
			<haxe_doc>Returns iterator of registered values.
	
	@return An iterator over the values.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="186">
			<f a=""><t path="Iterator"><c path="mdata.Dictionary.K"/></t></f>
			<haxe_doc>Returns array of registered keys.
	
	@return An array of keys.</haxe_doc>
		</keys>
		<clear public="1" set="method" line="171">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Clear all keys and values from the Dictionary.</haxe_doc>
		</clear>
		<exists public="1" set="method" line="152">
			<f a="key">
				<c path="mdata.Dictionary.K"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Returns true if key is registered.
	
	@param key The key to check for.
	@return A boolean indicating the presence of the key.</haxe_doc>
		</exists>
		<delete public="1" set="method" line="141">
			<f a="key">
				<c path="mdata.Dictionary.K"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Removes a key/value from the Dictionary.
	
	@deprecated Use remove(key) instead.
	
	@param key The key to delete.</haxe_doc>
		</delete>
		<remove public="1" set="method" line="114">
			<f a="key">
				<c path="mdata.Dictionary.K"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a key/value from the Dictionary.
	
	@param key The key to delete.
	@return True if the remove was successful, false if the key was not found.</haxe_doc>
		</remove>
		<get public="1" set="method" line="92">
			<f a="key">
				<c path="mdata.Dictionary.K"/>
				<c path="mdata.Dictionary.V"/>
			</f>
			<haxe_doc>Returns value for key or null if not registered.
	
	Note that a return value of null does not necessarily mean that the key does not exist as a
	value of null can be registered against a key. The safe option is to check 
	using dictionary.exists(key).
	
	@param key The key to return
	@return The value for key, or null if not found.</haxe_doc>
		</get>
		<set public="1" set="method" line="62">
			<f a="key:value">
				<c path="mdata.Dictionary.K"/>
				<c path="mdata.Dictionary.V"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Sets a key value pair. Updates value if key already exists, otherwise adds 
	to registry
	
	@param key The key to set.
	@param value The value to set.</haxe_doc>
		</set>
		<weakKeys public="1" set="null"><e path="Bool"/></weakKeys>
		<map><c path="flash.utils.Dictionary"/></map>
		<new public="1" set="method" line="49">
			<f a="?weakKeys">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@param weakKeys non functional in JavaScript. Included to maintain 
	consistency with flash dictionary API.</haxe_doc>
		</new>
		<haxe_doc>Cross platform dictionary class (object to object map) leveraging the native 
dictionary class for flash9 targets.

This supports both objects and primitives as keys, unlike haxe.ds.ObjectMap
which does not support primitive keys on some platforms.</haxe_doc>
	</class>
	<class path="minject.InjectionConfig" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/InjectionConfig.hx">
		<setInjector public="1" set="method" line="84"><f a="injector">
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></setInjector>
		<setResult public="1" set="method" line="70"><f a="result">
	<c path="minject.result.InjectionResult"/>
	<e path="Void"/>
</f></setResult>
		<hasOwnResponse public="1" set="method" line="65"><f a=""><e path="Bool"/></f></hasOwnResponse>
		<hasResponse public="1" set="method" line="60"><f a="injector">
	<c path="minject.Injector"/>
	<e path="Bool"/>
</f></hasResponse>
		<getResponse public="1" set="method" line="41"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></getResponse>
		<result><c path="minject.result.InjectionResult"/></result>
		<injector><c path="minject.Injector"/></injector>
		<injectionName public="1"><c path="String"/></injectionName>
		<request public="1"><c path="Class"><d/></c></request>
		<new public="1" set="method" line="35"><f a="request:injectionName">
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="minject._Injector.StringMap" params="T" file="/usr/lib/haxe/lib/minject/1,2,0/minject/Injector.hx" private="1" module="minject.Injector"><c path="Hash"><c path="minject._Injector.StringMap.T"/></c></typedef>
	<class path="minject.Injector" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/Injector.hx">
		<getFields set="method" line="476"><f a="type">
	<c path="Class"><d/></c>
	<a/>
</f></getFields>
		<getClassName set="method" line="470"><f a="forClass">
	<c path="Class"><d/></c>
	<c path="String"/>
</f></getClassName>
		<set_parentInjector set="method" line="451"><f a="value">
	<c path="minject.Injector"/>
	<c path="minject.Injector"/>
</f></set_parentInjector>
		<getConfigurationForRequest set="method" line="434"><f a="forClass:named:?traverseAncestors">
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Bool"/>
	<c path="minject.InjectionConfig"/>
</f></getConfigurationForRequest>
		<getInjectionPoints set="method" line="363"><f a="forClass">
	<c path="Class"><d/></c>
	<c path="minject.InjecteeDescription"/>
</f></getInjectionPoints>
		<getAncestorMapping public="1" set="method" line="342">
			<f a="forClass:?named">
				<c path="Class"><d/></c>
				<c path="String"/>
				<c path="minject.InjectionConfig"/>
			</f>
			<haxe_doc>Searches for an injection mapping in the ancestry of the injector. This 
	method is called when a dependency cannot be satisfied by this injector.</haxe_doc>
		</getAncestorMapping>
		<createChildInjector public="1" set="method" line="331">
			<f a=""><c path="minject.Injector"/></f>
			<haxe_doc>Create an injector that inherits rules from its parent
	
	@returns The injector</haxe_doc>
		</createChildInjector>
		<getInstance public="1" params="T" set="method" line="314">
			<f a="ofClass:?named">
				<c path="Class"><c path="getInstance.T"/></c>
				<c path="String"/>
				<c path="getInstance.T"/>
			</f>
			<haxe_doc>Create or retrieve an instance of the given class
	
	@param ofClass The class to retrieve.
	@param named An optional name (id)
	@return An instance</haxe_doc>
		</getInstance>
		<hasMapping public="1" set="method" line="295">
			<f a="forClass:?named">
				<c path="Class"><d/></c>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Does a rule exist to satsify such a request?

	@param clazz A class or interface
	@param named An optional name (id)
	@returns Whether such a mapping exists</haxe_doc>
		</hasMapping>
		<unmap public="1" set="method" line="276">
			<f a="theClass:?named">
				<c path="Class"><d/></c>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Remove a rule from the injector

	@param theClass A class or interface
	@param named An optional name (id)</haxe_doc>
		</unmap>
		<instantiate public="1" params="T" set="method" line="250">
			<f a="theClass">
				<c path="Class"><c path="instantiate.T"/></c>
				<c path="instantiate.T"/>
			</f>
			<haxe_doc><![CDATA[Create an object of the given class, supplying its dependencies as 
	constructor parameters if the used DI solution has support for 
	constructor injection
	
	<p>Adapters for DI solutions that don't support constructor 
	injection should just create a new instance and perform setter 
	and/or method injection on that.</p>
	
	<p>NOTE: This method will always create a new instance. If you need 
	to retrieve an instance consider using <code>getInstance</code></p>
	
	<p>The <code>Injector</code> should throw an <code>Error</code> if 
	it can't satisfy all dependencies of the injectee.</p>
	
	@param theClass The class to instantiate
	@returns The created instance]]></haxe_doc>
		</instantiate>
		<injectInto public="1" set="method" line="197">
			<f a="target">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Perform an injection into an object, satisfying all it's dependencies
	
	<p>The <code>Injector</code> should throw an <code>Error</code> if 
	it can't satisfy all dependencies of the injectee.</p>
	
	@param target The object to inject into - the Injectee]]></haxe_doc>
		</injectInto>
		<getMapping public="1" set="method" line="175">
			<f a="forClass:?named">
				<c path="Class"><d/></c>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc></haxe_doc>
		</getMapping>
		<mapRule public="1" set="method" line="166">
			<f a="whenAskedFor:useRule:?named">
				<c path="Class"><d/></c>
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[When asked for an instance of the class <code>whenAskedFor</code>
	use rule <code>useRule</code> to determine the correct injection.
	
	<p>This will use whatever injection is set by the given injection 
	rule as created using one of the other mapping methods.</p>
	
	@param whenAskedFor A class or interface
	@param useRule The rule to use for the injection
	@param named An optional name (id)
	
	@returns A reference to the rule for this injection. To be used with 
	<code>mapRule</code>]]></haxe_doc>
		</mapRule>
		<mapSingletonOf public="1" set="method" line="145">
			<f a="whenAskedFor:useSingletonOf:?named">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[When asked for an instance of the class <code>whenAskedFor</code>
	inject an instance of <code>useSingletonOf</code>.
	
	<p>This will create an instance on the first injection, but will 
	re-use that instance for subsequent injections.</p>
	
	@param whenAskedFor A class or interface
	@param useSingletonOf A class to instantiate
	@param named An optional name (id)
	
	@returns A reference to the rule for this injection. To be used with 
	<code>mapRule</code>]]></haxe_doc>
		</mapSingletonOf>
		<mapSingleton public="1" set="method" line="126">
			<f a="whenAskedFor:?named">
				<c path="Class"><d/></c>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[When asked for an instance of the class <code>whenAskedFor</code> 
	inject an instance of <code>whenAskedFor</code>.
	
	<p>This will create an instance on the first injection, but will 
	re-use that instance for subsequent injections.</p>
	
	@param whenAskedFor A class or interface
	@param named An optional name (id)
	
	@returns A reference to the rule for this injection. To be used with 
	<code>mapRule</code>]]></haxe_doc>
		</mapSingleton>
		<mapClass public="1" set="method" line="106">
			<f a="whenAskedFor:instantiateClass:?named">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[When asked for an instance of the class <code>whenAskedFor</code> 
	inject a new instance of <code>instantiateClass</code>.
	
	<p>This will create a new instance for each injection.</p>
	
	@param whenAskedFor A class or interface
	@param instantiateClass A class to instantiate
	@param named An optional name (id)

	@returns A reference to the rule for this injection. To be used with 
	<code>mapRule</code>]]></haxe_doc>
		</mapClass>
		<mapValue public="1" set="method" line="86">
			<f a="whenAskedFor:useValue:?named">
				<c path="Class"><d/></c>
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[When asked for an instance of the class <code>whenAskedFor</code> 
	inject the instance <code>useValue</code>.
	
	<p>This is used to register an existing instance with the injector 
	and treat it like a Singleton.</p>
	
	@param whenAskedFor A class or interface
	@param useValue An instance
	@param named An optional name (id)
	
	@returns A reference to the rule for this injection. To be used with 
	<code>mapRule</code>]]></haxe_doc>
		</mapValue>
		<injecteeDescriptions><c path="minject.ClassHash"><c path="minject.InjecteeDescription"/></c></injecteeDescriptions>
		<injectionConfigs><t path="minject._Injector.StringMap"><c path="minject.InjectionConfig"/></t></injectionConfigs>
		<parentInjector public="1" set="set_parentInjector">
			<c path="minject.Injector"/>
			<haxe_doc>The parent of this injector.</haxe_doc>
		</parentInjector>
		<attendedToInjectees public="1" set="null">
			<c path="minject._Injector.InjecteeSet"/>
			<haxe_doc>A set of instances that have already had their dependencies satisfied 
	by the injector.</haxe_doc>
		</attendedToInjectees>
		<new public="1" set="method" line="65"><f a=""><e path="Void"/></f></new>
		<haxe_doc>The dependency injector.</haxe_doc>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="minject._Injector.InjecteeSet" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/Injector.hx" private="1" module="minject.Injector">
		<iterator public="1" set="method" line="547">
			<f a=""><t path="Iterator"><e path="Bool"/></t></f>
			<haxe_doc>Under dynamic targets that don't support weak refs (js, avm1, neko) this will always return
	an empty iterator due to values not being stored in this set. This is to avoid memory leaks.</haxe_doc>
		</iterator>
		<delete public="1" set="method" line="534"><f a="value">
	<d/>
	<e path="Void"/>
</f></delete>
		<contains public="1" set="method" line="525"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<add public="1" set="method" line="516"><f a="value">
	<d/>
	<e path="Void"/>
</f></add>
		<store><c path="mdata.Dictionary">
	<d/>
	<e path="Bool"/>
</c></store>
		<new public="1" set="method" line="509"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Contains the set of objects which have been injected into.
 
Under dynamic languages that don't support weak references this set a hidden property 
on an injectee when added, to mark it as injected. This is to avoid storing a direct 
reference of it here, causing it never to be available for GC.</haxe_doc>
	</class>
	<class path="minject.ClassHash" params="T" file="/usr/lib/haxe/lib/minject/1,2,0/minject/Injector.hx" module="minject.Injector">
		<exists public="1" set="method" line="576"><f a="key">
	<c path="Class"><d/></c>
	<e path="Bool"/>
</f></exists>
		<get public="1" set="method" line="571"><f a="key">
	<c path="Class"><d/></c>
	<c path="minject.ClassHash.T"/>
</f></get>
		<set public="1" set="method" line="566"><f a="key:value">
	<c path="Class"><d/></c>
	<c path="minject.ClassHash.T"/>
	<e path="Void"/>
</f></set>
		<hash><t path="minject._Injector.StringMap"><c path="minject.ClassHash.T"/></t></hash>
		<new public="1" set="method" line="561"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="minject.InjecteeDescription" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/Injector.hx" module="minject.Injector">
		<injectionPoints public="1"><c path="Array"><c path="minject.point.InjectionPoint"/></c></injectionPoints>
		<ctor public="1"><c path="minject.point.InjectionPoint"/></ctor>
		<new public="1" set="method" line="587"><f a="ctor:injectionPoints">
	<c path="minject.point.InjectionPoint"/>
	<c path="Array"><c path="minject.point.InjectionPoint"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.InjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/InjectionPoint.hx">
		<initializeInjection set="method" line="42">
			<f a="meta">
				<d/>
				<e path="Void"/>
			</f>
			<meta><m n=":IgnoreCover"/></meta>
		</initializeInjection>
		<applyInjection public="1" set="method" line="36">
			<f a="target:injector">
				<d/>
				<c path="minject.Injector"/>
				<d/>
			</f>
			<meta><m n=":IgnoreCover"/></meta>
		</applyInjection>
		<new public="1" set="method" line="30"><f a="meta:injector">
	<d/>
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.MethodInjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/MethodInjectionPoint.hx">
		<extends path="minject.point.InjectionPoint"/>
		<gatherParameterValues set="method" line="95"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<c path="Array"><d/></c>
</f></gatherParameterValues>
		<gatherParameters set="method" line="56"><f a="meta">
	<d/>
	<e path="Void"/>
</f></gatherParameters>
		<initializeInjection set="method" line="50" override="1"><f a="meta">
	<d/>
	<e path="Void"/>
</f></initializeInjection>
		<applyInjection public="1" set="method" line="42" override="1"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<d/>
</f></applyInjection>
		<requiredParameters><c path="Int"/></requiredParameters>
		<_parameterInjectionConfigs><c path="Array"><d/></c></_parameterInjectionConfigs>
		<methodName><c path="String"/></methodName>
		<new public="1" set="method" line="36"><f a="meta:?injector">
	<d/>
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.ConstructorInjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/ConstructorInjectionPoint.hx">
		<extends path="minject.point.MethodInjectionPoint"/>
		<initializeInjection set="method" line="41" override="1"><f a="meta">
	<d/>
	<e path="Void"/>
</f></initializeInjection>
		<applyInjection public="1" set="method" line="34" override="1"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<d/>
</f></applyInjection>
		<new public="1" set="method" line="29"><f a="meta:forClass:?injector">
	<d/>
	<c path="Class"><d/></c>
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.ParameterInjectionConfig" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/MethodInjectionPoint.hx" module="minject.point.MethodInjectionPoint">
		<injectionName public="1"><c path="String"/></injectionName>
		<typeName public="1"><c path="String"/></typeName>
		<new public="1" set="method" line="129"><f a="typeName:injectionName">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.NoParamsConstructorInjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/NoParamsConstructorInjectionPoint.hx">
		<extends path="minject.point.InjectionPoint"/>
		<applyInjection public="1" set="method" line="35" override="1"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<d/>
</f></applyInjection>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="minject.point.PostConstructInjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/PostConstructInjectionPoint.hx">
		<extends path="minject.point.InjectionPoint"/>
		<initializeInjection set="method" line="47" override="1"><f a="meta">
	<d/>
	<e path="Void"/>
</f></initializeInjection>
		<applyInjection public="1" set="method" line="41" override="1"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<d/>
</f></applyInjection>
		<methodName><c path="String"/></methodName>
		<order public="1" set="null"><c path="Int"/></order>
		<new public="1" set="method" line="35"><f a="meta:?injector">
	<d/>
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.point.PropertyInjectionPoint" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/point/PropertyInjectionPoint.hx">
		<extends path="minject.point.InjectionPoint"/>
		<initializeInjection set="method" line="65" override="1"><f a="meta">
	<d/>
	<e path="Void"/>
</f></initializeInjection>
		<applyInjection public="1" set="method" line="42" override="1"><f a="target:injector">
	<d/>
	<c path="minject.Injector"/>
	<d/>
</f></applyInjection>
		<hasSetter><e path="Bool"/></hasSetter>
		<injectionName><c path="String"/></injectionName>
		<propertyType><c path="String"/></propertyType>
		<propertyName><c path="String"/></propertyName>
		<new public="1" set="method" line="37"><f a="meta:?injector">
	<d/>
	<c path="minject.Injector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.result.InjectionResult" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/result/InjectionResult.hx">
		<getResponse public="1" set="method" line="34">
			<f a="injector">
				<c path="minject.Injector"/>
				<d/>
			</f>
			<meta><m n=":IgnoreCover"/></meta>
		</getResponse>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="minject.result.InjectClassResult" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/result/InjectClassResult.hx">
		<extends path="minject.result.InjectionResult"/>
		<getResponse public="1" set="method" line="37" override="1"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></getResponse>
		<responseType><c path="Class"><d/></c></responseType>
		<new public="1" set="method" line="31"><f a="responseType">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.result.InjectOtherRuleResult" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/result/InjectOtherRuleResult.hx">
		<extends path="minject.result.InjectionResult"/>
		<getResponse public="1" set="method" line="38" override="1"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></getResponse>
		<rule><c path="minject.InjectionConfig"/></rule>
		<new public="1" set="method" line="32"><f a="rule">
	<c path="minject.InjectionConfig"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.result.InjectSingletonResult" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/result/InjectSingletonResult.hx">
		<extends path="minject.result.InjectionResult"/>
		<createResponse set="method" line="48"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></createResponse>
		<getResponse public="1" set="method" line="38" override="1"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></getResponse>
		<response><d/></response>
		<responseType><c path="Class"><d/></c></responseType>
		<new public="1" set="method" line="32"><f a="responseType">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="minject.result.InjectValueResult" params="" file="/usr/lib/haxe/lib/minject/1,2,0/minject/result/InjectValueResult.hx">
		<extends path="minject.result.InjectionResult"/>
		<getResponse public="1" set="method" line="37" override="1"><f a="injector">
	<c path="minject.Injector"/>
	<d/>
</f></getResponse>
		<value><d/></value>
		<new public="1" set="method" line="31"><f a="value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="mycompany.towerdefense.EntityCreator" params="" file="Source/mycompany/towerdefense/EntityCreator.hx">
		<createTower public="1" set="method" line="93"><f a="type:level:x:y">
	<e path="mycompany.towerdefense.enums.TowerType"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="ash.core.Entity"/>
</f></createTower>
		<createWaveBossMonsters public="1" set="method" line="85"><f a="wave:set">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></createWaveBossMonsters>
		<createWaveCreepMonsters public="1" set="method" line="77"><f a="wave:set">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></createWaveCreepMonsters>
		<createMonster public="1" set="method" line="52"><f a="currentTile">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="ash.core.Entity"/>
</f></createMonster>
		<createGame public="1" set="method" line="45"><f a=""><c path="ash.core.Entity"/></f></createGame>
		<destroyEntity public="1" set="method" line="41"><f a="entity">
	<c path="ash.core.Entity"/>
	<e path="Void"/>
</f></destroyEntity>
		<am public="1">
			<c path="starling.utils.AssetManager"/>
			<meta><m n="inject"/></meta>
		</am>
		<map public="1">
			<c path="mycompany.towerdefense.IsoMap"/>
			<meta><m n="inject"/></meta>
		</map>
		<goalTile public="1">
			<c path="mycompany.towerdefense.pathfinder.INode"/>
			<meta><m n="inject"><e>goalTile</e></m></meta>
		</goalTile>
		<engine public="1">
			<c path="ash.core.Engine"/>
			<meta><m n="inject"/></meta>
		</engine>
		<new public="1" set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.GameConfig" params="" file="Source/mycompany/towerdefense/GameConfig.hx">
		<height public="1"><c path="Float"/></height>
		<width public="1"><c path="Float"/></width>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="starling.events.EventDispatcher" params="" file="Lib/starling.swf@starling.events.EventDispatcher" extern="1">
		<addEventListener public="1" set="method"><f a="p1:p2">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></addEventListener>
		<removeEventListener public="1" set="method"><f a="p1:p2">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></removeEventListener>
		<removeEventListeners public="1" set="method"><f a="?p1">
	<c path="String"/>
	<e path="Void"/>
</f></removeEventListeners>
		<dispatchEvent public="1" set="method"><f a="p1">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></dispatchEvent>
		<invokeEvent public="1" set="method"><f a="p1">
	<c path="starling.events.Event"/>
	<e path="Bool"/>
</f></invokeEvent>
		<bubbleEvent public="1" set="method"><f a="p1">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></bubbleEvent>
		<dispatchEventWith public="1" set="method">
			<f a="p1:?p2:?p3">
				<c path="String"/>
				<e path="Bool"/>
				<d/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</dispatchEventWith>
		<hasEventListener public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.DisplayObject" params="" file="Lib/starling.swf@starling.display.DisplayObject" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<removeFromParent public="1" set="method">
			<f a="?p1">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p1</e>
	<e>false</e>
</m></meta>
		</removeFromParent>
		<getTransformationMatrix public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></getTransformationMatrix>
		<getBounds public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<hitTest public="1" set="method">
			<f a="p1:?p2">
				<c path="flash.geom.Point"/>
				<e path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</hitTest>
		<localToGlobal public="1" set="method"><f a="p1:?p2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<globalToLocal public="1" set="method"><f a="p1:?p2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<render public="1" set="method"><f a="p1:p2">
	<c path="starling.core.RenderSupport"/>
	<c path="Float"/>
	<e path="Void"/>
</f></render>
		<setParent public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></setParent>
		<base public="1" set="null"><c path="starling.display.DisplayObject"/></base>
		<blendMode public="1"><c path="String"/></blendMode>
		<hasVisibleArea public="1" set="null"><e path="Bool"/></hasVisibleArea>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<transformationMatrix public="1"><c path="flash.geom.Matrix"/></transformationMatrix>
		<root public="1" set="null"><c path="starling.display.DisplayObject"/></root>
		<scaleX public="1"><c path="Float"/></scaleX>
		<touchable public="1"><e path="Bool"/></touchable>
		<scaleY public="1"><c path="Float"/></scaleY>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<stage public="1" set="null"><c path="starling.display.Stage"/></stage>
		<filter public="1"><c path="starling.filters.FragmentFilter"/></filter>
		<visible public="1"><e path="Bool"/></visible>
		<rotation public="1"><c path="Float"/></rotation>
		<bounds public="1" set="null"><c path="flash.geom.Rectangle"/></bounds>
		<width public="1"><c path="Float"/></width>
		<parent public="1" set="null"><c path="starling.display.DisplayObjectContainer"/></parent>
		<skewX public="1"><c path="Float"/></skewX>
		<pivotX public="1"><c path="Float"/></pivotX>
		<name public="1"><c path="String"/></name>
		<pivotY public="1"><c path="Float"/></pivotY>
		<skewY public="1"><c path="Float"/></skewY>
		<height public="1"><c path="Float"/></height>
		<alpha public="1"><c path="Float"/></alpha>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.DisplayObjectContainer" params="" file="Lib/starling.swf@starling.display.DisplayObjectContainer" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<addChild public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="p1:p2">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></addChildAt>
		<removeChild public="1" set="method">
			<f a="p1:?p2">
				<c path="starling.display.DisplayObject"/>
				<e path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</removeChild>
		<removeChildAt public="1" set="method">
			<f a="p1:?p2">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?p1:?p2:?p3">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p3</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>0</e>
				</m>
			</meta>
		</removeChildren>
		<getChildAt public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<setChildIndex public="1" set="method"><f a="p1:p2">
	<c path="starling.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="p1:p2">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<sortChildren public="1" set="method"><f a="p1">
	<d/>
	<e path="Void"/>
</f></sortChildren>
		<contains public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<broadcastEvent public="1" set="method"><f a="p1">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></broadcastEvent>
		<broadcastEventWith public="1" set="method"><f a="p1:?p2">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></broadcastEventWith>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.Sprite" params="" file="Lib/starling.swf@starling.display.Sprite" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<flatten public="1" set="method"><f a=""><e path="Void"/></f></flatten>
		<unflatten public="1" set="method"><f a=""><e path="Void"/></f></unflatten>
		<isFlattened public="1" set="null"><e path="Bool"/></isFlattened>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="mycompany.towerdefense.IsoMap" params="" file="Source/mycompany/towerdefense/IsoMap.hx">
		<extends path="starling.display.Sprite"/>
		<drawPath public="1" set="method" line="220"><f a="tiles">
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
	<e path="Void"/>
</f></drawPath>
		<reset public="1" set="method" line="212"><f a=""><e path="Void"/></f></reset>
		<findConnectedTiles public="1" set="method" line="196"><f a="tile">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
</f></findConnectedTiles>
		<getTile public="1" set="method" line="187"><f a="row:col">
	<c path="Int"/>
	<c path="Int"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
</f></getTile>
		<onTouch set="method" line="160"><f a="event">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></onTouch>
		<disableTile set="method" line="156"><f a="tile">
	<c path="mycompany.towerdefense.IsoTile"/>
	<e path="Void"/>
</f></disableTile>
		<enableTile set="method" line="152"><f a="tile">
	<c path="mycompany.towerdefense.IsoTile"/>
	<e path="Void"/>
</f></enableTile>
		<onTileClick set="method" line="131"><f a="event">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></onTileClick>
		<onTileOut set="method" line="126"><f a="event">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></onTileOut>
		<onTileOver set="method" line="121"><f a="event">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></onTileOver>
		<disableTiles public="1" set="method" line="117"><f a=""><e path="Void"/></f></disableTiles>
		<enableTiles public="1" set="method" line="113"><f a=""><e path="Void"/></f></enableTiles>
		<drawMap public="1" set="method" line="95"><f a=""><e path="Void"/></f></drawMap>
		<initialize set="method" line="86"><f a="rows:columns">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></initialize>
		<get_container set="method" line="77"><f a=""><c path="starling.display.Sprite"/></f></get_container>
		<container public="1" get="get_container" set="null"><c path="starling.display.Sprite"/></container>
		<_mapHolder><c path="starling.display.Sprite"/></_mapHolder>
		<_map><c path="Array"><c path="Array"><c path="mycompany.towerdefense.IsoTile"/></c></c></_map>
		<_obsTile5><c path="mycompany.towerdefense.IsoTile"/></_obsTile5>
		<_obsTile4><c path="mycompany.towerdefense.IsoTile"/></_obsTile4>
		<_obsTile3><c path="mycompany.towerdefense.IsoTile"/></_obsTile3>
		<_obsTile2><c path="mycompany.towerdefense.IsoTile"/></_obsTile2>
		<_obsTile1><c path="mycompany.towerdefense.IsoTile"/></_obsTile1>
		<setEndTile set="method" line="61"><f a="value">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
</f></setEndTile>
		<getEndTile set="method" line="58"><f a=""><c path="mycompany.towerdefense.pathfinder.INode"/></f></getEndTile>
		<endTile public="1" get="getEndTile" set="setEndTile"><c path="mycompany.towerdefense.pathfinder.INode"/></endTile>
		<_endTile><c path="mycompany.towerdefense.pathfinder.INode"/></_endTile>
		<setStartTile set="method" line="49"><f a="value">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
</f></setStartTile>
		<getStartTile set="method" line="46"><f a=""><c path="mycompany.towerdefense.pathfinder.INode"/></f></getStartTile>
		<startTile public="1" get="getStartTile" set="setStartTile"><c path="mycompany.towerdefense.pathfinder.INode"/></startTile>
		<_startTile><c path="mycompany.towerdefense.pathfinder.INode"/></_startTile>
		<setColumns set="method" line="37"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setColumns>
		<getColumns set="method" line="34"><f a=""><c path="Int"/></f></getColumns>
		<columns public="1" get="getColumns" set="setColumns"><c path="Int"/></columns>
		<_columns>
			<c path="Int"/>
			<haxe_doc>* The number of grid columns.</haxe_doc>
		</_columns>
		<setRows set="method" line="25"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setRows>
		<getRows set="method" line="22"><f a=""><c path="Int"/></f></getRows>
		<rows public="1" get="getRows" set="setRows"><c path="Int"/></rows>
		<_rows>
			<c path="Int"/>
			<haxe_doc>* The number of row columns</haxe_doc>
		</_rows>
		<new public="1" set="method" line="81"><f a="?rows:?columns">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.pathfinder.INode" params="" file="Source/mycompany/towerdefense/pathfinder/INode.hx" interface="1">
		<ty public="1" get="get_ty" set="set_ty"><c path="Float"/></ty>
		<tx public="1" get="get_tx" set="set_tx"><c path="Float"/></tx>
		<traversable public="1" get="get_traversable" set="set_traversable"><e path="Bool"/></traversable>
		<parentNode public="1" get="get_parentNode" set="set_parentNode"><c path="mycompany.towerdefense.pathfinder.INode"/></parentNode>
		<col public="1" get="get_col" set="set_col"><c path="Int"/></col>
		<row public="1" get="get_row" set="set_row"><c path="Int"/></row>
		<h public="1" get="get_h" set="set_h"><c path="Float"/></h>
		<g public="1" get="get_g" set="set_g"><c path="Float"/></g>
		<f public="1" get="get_f" set="set_f"><c path="Float"/></f>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta><m n="interface"/></meta>
	</class>
	<class path="mycompany.towerdefense.IsoTile" params="" file="Source/mycompany/towerdefense/IsoTile.hx">
		<extends path="starling.display.Sprite"/>
		<implements path="mycompany.towerdefense.pathfinder.INode"/>
		<TILE_SIZE get="inline" set="null" line="14" static="1"><c path="Int"/></TILE_SIZE>
		<W get="inline" set="null" line="16" static="1"><c path="Int"/></W>
		<H get="inline" set="null" line="17" static="1"><c path="Int"/></H>
		<toString public="1" set="method" line="177"><f a=""><c path="String"/></f></toString>
		<reset public="1" set="method" line="170"><f a=""><e path="Void"/></f></reset>
		<highlight public="1" set="method" line="157"><f a="?color">
	<c path="Int"/>
	<e path="Void"/>
</f></highlight>
		<construct set="method" line="138"><f a=""><e path="Void"/></f></construct>
		<initialize set="method" line="134"><f a=""><e path="Void"/></f></initialize>
		<_tile><c path="starling.display.Image"/></_tile>
		<_col><c path="Int"/></_col>
		<_row><c path="Int"/></_row>
		<set_ty set="method" line="115"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_ty>
		<get_ty set="method" line="112"><f a=""><c path="Float"/></f></get_ty>
		<ty public="1" get="get_ty" set="set_ty"><c path="Float"/></ty>
		<set_tx set="method" line="107"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_tx>
		<get_tx set="method" line="104"><f a=""><c path="Float"/></f></get_tx>
		<tx public="1" get="get_tx" set="set_tx"><c path="Float"/></tx>
		<set_traversable set="method" line="99"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_traversable>
		<get_traversable set="method" line="96"><f a=""><e path="Bool"/></f></get_traversable>
		<traversable public="1" get="get_traversable" set="set_traversable"><e path="Bool"/></traversable>
		<set_parentNode set="method" line="88"><f a="value">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
</f></set_parentNode>
		<get_parentNode set="method" line="85"><f a=""><c path="mycompany.towerdefense.pathfinder.INode"/></f></get_parentNode>
		<parentNode public="1" get="get_parentNode" set="set_parentNode"><c path="mycompany.towerdefense.pathfinder.INode"/></parentNode>
		<set_h set="method" line="77"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_h>
		<get_h set="method" line="74"><f a=""><c path="Float"/></f></get_h>
		<h public="1" get="get_h" set="set_h"><c path="Float"/></h>
		<set_g set="method" line="66"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_g>
		<get_g set="method" line="63"><f a=""><c path="Float"/></f></get_g>
		<g public="1" get="get_g" set="set_g"><c path="Float"/></g>
		<set_f set="method" line="55"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_f>
		<get_f set="method" line="52"><f a=""><c path="Float"/></f></get_f>
		<f public="1" get="get_f" set="set_f"><c path="Float"/></f>
		<set_col set="method" line="44"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_col>
		<get_col set="method" line="41"><f a=""><c path="Int"/></f></get_col>
		<col public="1" get="get_col" set="set_col"><c path="Int"/></col>
		<set_row set="method" line="33"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_row>
		<get_row set="method" line="30"><f a=""><c path="Int"/></f></get_row>
		<row public="1" get="get_row" set="set_row"><c path="Int"/></row>
		<_traversable><e path="Bool"/></_traversable>
		<_h><c path="Float"/></_h>
		<_g><c path="Float"/></_g>
		<_f><c path="Float"/></_f>
		<_parentNode><c path="mycompany.towerdefense.pathfinder.INode"/></_parentNode>
		<new public="1" set="method" line="123"><f a="r:c">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.Main" params="" file="Source/mycompany/towerdefense/Main.hx">
		<extends path="flash.display.Sprite"/>
		<main set="method" line="58" static="1"><f a=""><e path="Void"/></f></main>
		<deactivate set="method" line="52"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></deactivate>
		<init set="method" line="30"><f a=""><e path="Void"/></f></init>
		<onEnterFrame set="method" line="22"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<_starlingApp><c path="starling.core.Starling"/></_starlingApp>
		<new public="1" set="method" line="17"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.TowerDefense" params="" file="Source/mycompany/towerdefense/TowerDefense.hx">
		<extends path="starling.display.Sprite"/>
		<start public="1" set="method" line="105"><f a=""><e path="Void"/></f></start>
		<prepare set="method" line="45"><f a=""><e path="Void"/></f></prepare>
		<_ui><c path="mycompany.towerdefense.ui.InGameUI"/></_ui>
		<_am><c path="starling.utils.AssetManager"/></_am>
		<_tickProvider><c path="ash.tick.FrameTickProvider"/></_tickProvider>
		<_timer><c path="mycompany.towerdefense.utils.AccurateTimer"/></_timer>
		<_injector><c path="minject.Injector"/></_injector>
		<_map><c path="mycompany.towerdefense.IsoMap"/></_map>
		<_engine><c path="ash.core.Engine"/></_engine>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.MonsterSpriteSheet" params="" file="Source/mycompany/towerdefense/TowerDefense.hx" module="mycompany.towerdefense.TowerDefense">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="116"><f a=""><e path="Void"/></f></new>
		<meta><m n=":bitmap"><e>Assets/monster.png</e></m></meta>
	</class>
	<class path="mycompany.towerdefense.components.Collision" params="" file="Source/mycompany/towerdefense/components/Collision.hx">
		<radius public="1"><c path="Float"/></radius>
		<new public="1" set="method" line="10"><f a="radius">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.Display" params="" file="Source/mycompany/towerdefense/components/Display.hx">
		<displayObject public="1"><c path="starling.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="10"><f a="displayObject">
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.GameState" params="" file="Source/mycompany/towerdefense/components/GameState.hx">
		<monsterSets public="1"><c path="Int"/></monsterSets>
		<wavesPerMonsterSet public="1"><c path="Int"/></wavesPerMonsterSet>
		<currentWave public="1"><c path="Int"/></currentWave>
		<life public="1"><c path="Float"/></life>
		<new public="1" set="method" line="13"><f a="wavesPerMonsterSet:monsterSets">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.Monster" params="" file="Source/mycompany/towerdefense/components/Monster.hx">
		<speed public="1"><c path="Float"/></speed>
		<direction public="1"><c path="Int"/></direction>
		<life public="1"><c path="Float"/></life>
		<new public="1" set="method" line="12"><f a="speed">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.Motion" params="" file="Source/mycompany/towerdefense/components/Motion.hx">
		<damping public="1"><c path="Float"/></damping>
		<angularVelocity public="1"><c path="Float"/></angularVelocity>
		<velocityY public="1"><c path="Float"/></velocityY>
		<velocityX public="1"><c path="Float"/></velocityX>
		<new public="1" set="method" line="13"><f a="velocityX:velocityY:angularVelocity:damping">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.Position" params="" file="Source/mycompany/towerdefense/components/Position.hx">
		<direction public="1"><e path="mycompany.towerdefense.enums.TileDirection"/></direction>
		<collisionRadius public="1"><c path="Float"/></collisionRadius>
		<rotation public="1"><c path="Float"/></rotation>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method" line="15"><f a="?x:?y:?rotation:?collisionRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.Tile" params="" file="Source/mycompany/towerdefense/components/Tile.hx">
		<currentTile public="1"><c path="mycompany.towerdefense.pathfinder.INode"/></currentTile>
		<pathNodes public="1"><c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c></pathNodes>
		<new public="1" set="method" line="11"><f a="currentTile:pathNodes">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.components.TileDisplay" params="" file="Source/mycompany/towerdefense/components/TileDisplay.hx">
		<displayObject public="1"><c path="mycompany.towerdefense.views.ITileView"/></displayObject>
		<new public="1" set="method" line="8"><f a="displayObject">
	<c path="mycompany.towerdefense.views.ITileView"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="mycompany.towerdefense.components.Tower" params="" file="Source/mycompany/towerdefense/components/Tower.hx">
		<level public="1"><c path="Int"/></level>
		<type public="1"><e path="mycompany.towerdefense.enums.TowerType"/></type>
		<new public="1" set="method" line="12"><f a="type:level">
	<e path="mycompany.towerdefense.enums.TowerType"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<enum path="mycompany.towerdefense.enums.TileDirection" params="" file="Source/mycompany/towerdefense/enums/TileDirection.hx">
		<W/>
		<SW/>
		<SE/>
		<S/>
		<NW/>
		<NONE/>
		<NE/>
		<N/>
		<E/>
	</enum>
	<enum path="mycompany.towerdefense.enums.TowerType" params="" file="Source/mycompany/towerdefense/enums/TowerType.hx">
		<LIGHTNING/>
		<ICE/>
		<FIRE/>
		<BASIC/>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</enum>
	<class path="mycompany.towerdefense.nodes.GameNode" params="" file="Source/mycompany/towerdefense/nodes/GameNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.GameNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="8" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<state public="1"><c path="mycompany.towerdefense.components.GameState"/></state>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.nodes.MonsterNode" params="" file="Source/mycompany/towerdefense/nodes/MonsterNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.MonsterNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="8" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<monster public="1"><c path="mycompany.towerdefense.components.Monster"/></monster>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.nodes.MovementNode" params="" file="Source/mycompany/towerdefense/nodes/MovementNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.MovementNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="10" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<motion public="1"><c path="mycompany.towerdefense.components.Motion"/></motion>
		<position public="1"><c path="mycompany.towerdefense.components.Position"/></position>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.nodes.RenderNode" params="" file="Source/mycompany/towerdefense/nodes/RenderNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.RenderNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="10" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<display public="1"><c path="mycompany.towerdefense.components.Display"/></display>
		<position public="1"><c path="mycompany.towerdefense.components.Position"/></position>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.nodes.TileRenderNode" params="" file="Source/mycompany/towerdefense/nodes/TileRenderNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.TileRenderNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="7" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<display public="1"><c path="mycompany.towerdefense.components.TileDisplay"/></display>
		<position public="1"><c path="mycompany.towerdefense.components.Position"/></position>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.nodes.TileTraversalNode" params="" file="Source/mycompany/towerdefense/nodes/TileTraversalNode.hx">
		<extends path="ash.core.Node"><c path="mycompany.towerdefense.nodes.TileTraversalNode"/></extends>
		<_components static="1"><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></_components>
		<_getComponents public="1" get="inline" set="null" line="12" static="1"><f a=""><c path="ash.ObjectMap">
	<c path="Class"><d/></c>
	<c path="String"/>
</c></f></_getComponents>
		<display public="1"><c path="mycompany.towerdefense.components.TileDisplay"/></display>
		<position public="1"><c path="mycompany.towerdefense.components.Position"/></position>
		<motion public="1"><c path="mycompany.towerdefense.components.Motion"/></motion>
		<tile public="1"><c path="mycompany.towerdefense.components.Tile"/></tile>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="mycompany.towerdefense.pathfinder.SearchHelper" params="" file="Source/mycompany/towerdefense/pathfinder/SearchHelper.hx">
		<heuristic public="1" line="9" static="1"><f a="node:destinationNode:?cost:?diagonalCost">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></heuristic>
		<findPath public="1" set="method" line="11" static="1"><f a="firstNode:destinationNode:connectedNodeFunction">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<f a="">
		<c path="mycompany.towerdefense.pathfinder.INode"/>
		<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
	</f>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
</f></findPath>
		<buildPath public="1" set="method" line="93" static="1"><f a="destinationNode:startNode">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
</f></buildPath>
		<isOpen public="1" set="method" line="105" static="1"><f a="node:openNodes">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
	<e path="Bool"/>
</f></isOpen>
		<isClosed public="1" set="method" line="113" static="1"><f a="node:closedNodes">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Array"><c path="mycompany.towerdefense.pathfinder.INode"/></c>
	<e path="Bool"/>
</f></isClosed>
		<euclidianHeuristic public="1" set="method" line="126" static="1">
			<f a="node:destinationNode:?cost:?diagonalCost">
				<c path="mycompany.towerdefense.pathfinder.INode"/>
				<c path="mycompany.towerdefense.pathfinder.INode"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>**************************************************************************** 
	*
	*	These are our avaailable heuristics 
	*
	****************************************************************************</haxe_doc>
		</euclidianHeuristic>
		<manhattanHeuristic public="1" set="method" line="134" static="1"><f a="node:destinationNode:?cost:?diagonalCost">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></manhattanHeuristic>
		<diagonalHeuristic public="1" set="method" line="140" static="1"><f a="node:destinationNode:?cost:?diagonalCost">
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></diagonalHeuristic>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.systems.GameSystem" params="" file="Source/mycompany/towerdefense/systems/GameSystem.hx">
		<extends path="ash.core.System"/>
		<removeFromEngine public="1" set="method" line="65" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></removeFromEngine>
		<update public="1" set="method" line="45" override="1"><f a="time">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<addToEngine public="1" set="method" line="40" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></addToEngine>
		<_timer><c path="mycompany.towerdefense.utils.AccurateTimer"/></_timer>
		<_config><c path="mycompany.towerdefense.GameConfig"/></_config>
		<_creator><c path="mycompany.towerdefense.EntityCreator"/></_creator>
		<_monsterNodes><c path="ash.core.NodeList"><c path="mycompany.towerdefense.nodes.MonsterNode"/></c></_monsterNodes>
		<_gameNodes><c path="ash.core.NodeList"><c path="mycompany.towerdefense.nodes.GameNode"/></c></_gameNodes>
		<config public="1">
			<c path="mycompany.towerdefense.GameConfig"/>
			<meta><m n="inject"/></meta>
		</config>
		<creator public="1">
			<c path="mycompany.towerdefense.EntityCreator"/>
			<meta><m n="inject"/></meta>
		</creator>
		<goalTile public="1">
			<c path="mycompany.towerdefense.pathfinder.INode"/>
			<meta><m n="inject"><e>goalTile</e></m></meta>
		</goalTile>
		<startTile public="1">
			<c path="mycompany.towerdefense.pathfinder.INode"/>
			<meta><m n="inject"><e>startTile</e></m></meta>
		</startTile>
		<new public="1" set="method" line="36"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.systems.MovementSystem" params="" file="Source/mycompany/towerdefense/systems/MovementSystem.hx">
		<extends path="ash.tools.ListIteratingSystem"><c path="mycompany.towerdefense.nodes.MovementNode"/></extends>
		<updateNode set="method" line="17"><f a="node:time">
	<c path="mycompany.towerdefense.nodes.MovementNode"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateNode>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.systems.RenderSystem" params="" file="Source/mycompany/towerdefense/systems/RenderSystem.hx">
		<extends path="ash.core.System"/>
		<removeFromEngine public="1" set="method" line="54" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></removeFromEngine>
		<update public="1" set="method" line="43" override="1"><f a="time">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<removeFromDisplay set="method" line="39"><f a="node">
	<c path="mycompany.towerdefense.nodes.RenderNode"/>
	<e path="Void"/>
</f></removeFromDisplay>
		<addToDisplay set="method" line="35"><f a="node">
	<c path="mycompany.towerdefense.nodes.RenderNode"/>
	<e path="Void"/>
</f></addToDisplay>
		<addToEngine public="1" set="method" line="26" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></addToEngine>
		<_renderNodes><c path="ash.core.NodeList"><c path="mycompany.towerdefense.nodes.RenderNode"/></c></_renderNodes>
		<container public="1"><c path="starling.display.DisplayObjectContainer"/></container>
		<new public="1" set="method" line="21"><f a="container">
	<c path="starling.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.systems.TileRenderSystem" params="" file="Source/mycompany/towerdefense/systems/TileRenderSystem.hx">
		<extends path="ash.core.System"/>
		<removeFromEngine public="1" set="method" line="55" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></removeFromEngine>
		<update public="1" set="method" line="44" override="1"><f a="time">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<removeFromDisplay set="method" line="40"><f a="node">
	<c path="mycompany.towerdefense.nodes.TileRenderNode"/>
	<e path="Void"/>
</f></removeFromDisplay>
		<addToDisplay set="method" line="36"><f a="node">
	<c path="mycompany.towerdefense.nodes.TileRenderNode"/>
	<e path="Void"/>
</f></addToDisplay>
		<addToEngine public="1" set="method" line="27" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<e path="Void"/>
</f></addToEngine>
		<_renderNodes><c path="ash.core.NodeList"><c path="mycompany.towerdefense.nodes.TileRenderNode"/></c></_renderNodes>
		<container public="1"><c path="starling.display.DisplayObjectContainer"/></container>
		<new public="1" set="method" line="22"><f a="container">
	<c path="starling.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.systems.TileTraversalSystem" params="" file="Source/mycompany/towerdefense/systems/TileTraversalSystem.hx">
		<extends path="ash.tools.ListIteratingSystem"><c path="mycompany.towerdefense.nodes.TileTraversalNode"/></extends>
		<getTargetTile set="method" line="82"><f a="node">
	<c path="mycompany.towerdefense.nodes.TileTraversalNode"/>
	<c path="mycompany.towerdefense.pathfinder.INode"/>
</f></getTargetTile>
		<updateNode set="method" line="36"><f a="node:time">
	<c path="mycompany.towerdefense.nodes.TileTraversalNode"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateNode>
		<goalTile public="1">
			<c path="mycompany.towerdefense.pathfinder.INode"/>
			<meta><m n="inject"><e>goalTile</e></m></meta>
		</goalTile>
		<startTile public="1">
			<c path="mycompany.towerdefense.pathfinder.INode"/>
			<meta><m n="inject"><e>startTile</e></m></meta>
		</startTile>
		<map public="1">
			<c path="mycompany.towerdefense.IsoMap"/>
			<meta><m n="inject"/></meta>
		</map>
		<creator public="1">
			<c path="mycompany.towerdefense.EntityCreator"/>
			<meta><m n="inject"/></meta>
		</creator>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.ui.InGameUI" params="" file="Source/mycompany/towerdefense/ui/InGameUI.hx">
		<createUI set="method" line="21"><f a=""><e path="Void"/></f></createUI>
		<_buildingPanel><c path="starling.display.Image"/></_buildingPanel>
		<_targetContainer><c path="starling.display.Sprite"/></_targetContainer>
		<new public="1" set="method" line="15"><f a="targetContainer">
	<c path="starling.display.Sprite"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="mycompany.towerdefense.utils.AccurateTimer" params="" file="Source/mycompany/towerdefense/utils/AccurateTimer.hx">
		<set_currentCount set="method" line="48"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_currentCount>
		<get_currentCount set="method" line="45"><f a=""><c path="Int"/></f></get_currentCount>
		<currentCount public="1" get="get_currentCount" set="set_currentCount"><c path="Int"/></currentCount>
		<set_delay set="method" line="40"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_delay>
		<get_delay set="method" line="37"><f a=""><c path="Int"/></f></get_delay>
		<delay public="1" get="get_delay" set="set_delay"><c path="Int"/></delay>
		<onTimer set="method" line="32"><f a=""><e path="Void"/></f></onTimer>
		<stop public="1" set="method" line="28"><f a=""><e path="Void"/></f></stop>
		<reset public="1" set="method" line="24"><f a=""><e path="Void"/></f></reset>
		<start public="1" set="method" line="19"><f a=""><e path="Void"/></f></start>
		<_currentCount><c path="Int"/></_currentCount>
		<_delay><c path="Int"/></_delay>
		<_lastTime><c path="Date"/></_lastTime>
		<_timer><c path="haxe.Timer"/></_timer>
		<new public="1" set="method" line="14"><f a="delay">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="mycompany.towerdefense.views.ITileView" params="" file="Source/mycompany/towerdefense/views/ITileView.hx" interface="1">
		<direction public="1" get="get_direction" set="set_direction"><e path="mycompany.towerdefense.enums.TileDirection"/></direction>
		<meta><m n="interface"/></meta>
	</class>
	<class path="mycompany.towerdefense.views.MonsterView" params="" file="Source/mycompany/towerdefense/views/MonsterView.hx">
		<extends path="starling.display.Sprite"/>
		<implements path="mycompany.towerdefense.views.ITileView"/>
		<hideAllAnimations set="method" line="95"><f a=""><e path="Void"/></f></hideAllAnimations>
		<set_direction set="method" line="76"><f a="value">
	<e path="mycompany.towerdefense.enums.TileDirection"/>
	<e path="mycompany.towerdefense.enums.TileDirection"/>
</f></set_direction>
		<get_direction set="method" line="75"><f a=""><e path="mycompany.towerdefense.enums.TileDirection"/></f></get_direction>
		<_direction><e path="mycompany.towerdefense.enums.TileDirection"/></_direction>
		<direction public="1" get="get_direction" set="set_direction"><e path="mycompany.towerdefense.enums.TileDirection"/></direction>
		<_walkingNW><c path="starling.display.MovieClip"/></_walkingNW>
		<_walkingW><c path="starling.display.MovieClip"/></_walkingW>
		<_walkingSW><c path="starling.display.MovieClip"/></_walkingSW>
		<_walkingS><c path="starling.display.MovieClip"/></_walkingS>
		<_walkingSE><c path="starling.display.MovieClip"/></_walkingSE>
		<_walkingE><c path="starling.display.MovieClip"/></_walkingE>
		<_walkingNE><c path="starling.display.MovieClip"/></_walkingNE>
		<_walkingN><c path="starling.display.MovieClip"/></_walkingN>
		<_animation><c path="com.eclecticdesignstudio.spritesheet.AnimatedSprite"/></_animation>
		<new public="1" set="method" line="34"><f a="walkingN:walkingNE:walkingE:walkingSE:walkingS:walkingSW:walkingW:walkingNW">
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<c path="starling.display.MovieClip"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="starling.display.Quad" params="" file="Lib/starling.swf@starling.display.Quad" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<mVertexData>
			<c path="starling.utils.VertexData"/>
			<meta><m n=":protected"/></meta>
		</mVertexData>
		<onVertexDataChanged set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</onVertexDataChanged>
		<getVertexColor public="1" set="method"><f a="p1">
	<c path="Int"/>
	<t path="UInt"/>
</f></getVertexColor>
		<setVertexColor public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setVertexColor>
		<getVertexAlpha public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="Float"/>
</f></getVertexAlpha>
		<setVertexAlpha public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setVertexAlpha>
		<copyVertexDataTo public="1" set="method">
			<f a="p1:?p2">
				<c path="starling.utils.VertexData"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>0</e>
</m></meta>
		</copyVertexDataTo>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<color public="1"><t path="UInt"/></color>
		<new public="1" set="method">
			<f a="p1:p2:?p3:?p4">
				<c path="Float"/>
				<c path="Float"/>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p4</e>
					<e>true</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>16777215</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.display.Image" params="" file="Lib/starling.swf@starling.display.Image" extern="1">
		<extends path="starling.display.Quad"/>
		<fromBitmap public="1" set="method" static="1">
			<f a="p1:?p2:?p3">
				<c path="flash.display.Bitmap"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.display.Image"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p3</e>
					<e>1</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmap>
		<readjustSize public="1" set="method"><f a=""><e path="Void"/></f></readjustSize>
		<setTexCoords public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></setTexCoords>
		<getTexCoords public="1" set="method"><f a="p1:?p2">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getTexCoords>
		<smoothing public="1"><c path="String"/></smoothing>
		<texture public="1"><c path="starling.textures.Texture"/></texture>
		<new public="1" set="method"><f a="p1">
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="mycompany.towerdefense.views.TowerView" params="" file="Source/mycompany/towerdefense/views/TowerView.hx">
		<extends path="starling.display.Image"/>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author christiannoelmascarinas</haxe_doc>
	</class>
	<class path="nme.Assets" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/Assets.hx">
		<cachedBitmapData public="1" line="31" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="41" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="67" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getMovieClip public="1" set="method" line="80" static="1">
			<f a="id">
				<c path="String"/>
				<c path="format.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of a library MovieClip
	 * @usage		var movieClip = Assets.getMovieClip("library:BouncingBall");
	 * @param	id		The library and ID for the MovieClip
	 * @return		A new Sound object</haxe_doc>
		</getMovieClip>
		<getSound public="1" set="method" line="93" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="106" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
	</class>
	<typedef path="nme.Vector" params="T" file="/usr/lib/haxe/lib/nme/3,5,5/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.BitmapData" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<class path="nme.display.Tilesheet" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="137" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="138" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="139" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="140" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="144" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="147" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="148" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="155" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="271">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to(0, 0) and
	 * tile 1 to(10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The native.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed(Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing(Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="240"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="209"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="194"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="185"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="167"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="nme.geom.Matrix" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<typedef path="nme.media.Sound" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.text.Font" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="/usr/lib/haxe/lib/nme/3,5,5/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="starling.animation.IAnimatable" params="" file="Lib/starling.swf@starling.animation.IAnimatable" extern="1" interface="1"><advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime></class>
	<class path="starling.animation.DelayedCall" params="" file="Lib/starling.swf@starling.animation.DelayedCall" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<implements path="starling.animation.IAnimatable"/>
		<reset public="1" set="method"><f a="p1:p2:?p3">
	<d/>
	<c path="Float"/>
	<c path="Array"><d/></c>
	<c path="starling.animation.DelayedCall"/>
</f></reset>
		<advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime>
		<currentTime public="1" set="null"><c path="Float"/></currentTime>
		<isComplete public="1" set="null"><e path="Bool"/></isComplete>
		<repeatCount public="1"><c path="Int"/></repeatCount>
		<totalTime public="1" set="null"><c path="Float"/></totalTime>
		<new public="1" set="method"><f a="p1:p2:?p3">
	<d/>
	<c path="Float"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.animation.Juggler" params="" file="Lib/starling.swf@starling.animation.Juggler" extern="1">
		<implements path="starling.animation.IAnimatable"/>
		<add public="1" set="method"><f a="p1">
	<c path="starling.animation.IAnimatable"/>
	<e path="Void"/>
</f></add>
		<contains public="1" set="method"><f a="p1">
	<c path="starling.animation.IAnimatable"/>
	<e path="Bool"/>
</f></contains>
		<remove public="1" set="method"><f a="p1">
	<c path="starling.animation.IAnimatable"/>
	<e path="Void"/>
</f></remove>
		<removeTweens public="1" set="method"><f a="p1">
	<d/>
	<e path="Void"/>
</f></removeTweens>
		<purge public="1" set="method"><f a=""><e path="Void"/></f></purge>
		<delayCall public="1" set="method"><f a="p1:p2:?p3:?p4:?p5:?p6:?p7">
	<d/>
	<c path="Float"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="starling.animation.DelayedCall"/>
</f></delayCall>
		<tween public="1" set="method"><f a="p1:p2:p3">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></tween>
		<advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime>
		<elapsedTime public="1" set="null"><c path="Float"/></elapsedTime>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.core.RenderSupport" params="" file="Lib/starling.swf@starling.core.RenderSupport" extern="1">
		<assembleAgal public="1" set="method" static="1"><f a="p1:p2:?p3">
	<c path="String"/>
	<c path="String"/>
	<c path="flash.display3D.Program3D"/>
	<c path="flash.display3D.Program3D"/>
</f></assembleAgal>
		<clear public="1" set="method" static="1">
			<f a="?p1:?p2">
				<t path="UInt"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p2</e>
					<e>0.</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>0</e>
				</m>
			</meta>
		</clear>
		<setBlendFactors public="1" set="method" static="1"><f a="p1:?p2">
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></setBlendFactors>
		<setDefaultBlendFactors public="1" set="method" static="1"><f a="p1">
	<e path="Bool"/>
	<e path="Void"/>
</f></setDefaultBlendFactors>
		<transformMatrixForObject public="1" set="method" static="1"><f a="p1:p2">
	<c path="flash.geom.Matrix"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></transformMatrixForObject>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<setOrthographicProjection public="1" set="method"><f a="p1:p2:p3:p4">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setOrthographicProjection>
		<loadIdentity public="1" set="method"><f a=""><e path="Void"/></f></loadIdentity>
		<translateMatrix public="1" set="method"><f a="p1:p2">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translateMatrix>
		<rotateMatrix public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></rotateMatrix>
		<scaleMatrix public="1" set="method"><f a="p1:p2">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scaleMatrix>
		<prependMatrix public="1" set="method"><f a="p1">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></prependMatrix>
		<transformMatrix public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></transformMatrix>
		<pushMatrix public="1" set="method"><f a=""><e path="Void"/></f></pushMatrix>
		<popMatrix public="1" set="method"><f a=""><e path="Void"/></f></popMatrix>
		<resetMatrix public="1" set="method"><f a=""><e path="Void"/></f></resetMatrix>
		<applyBlendMode public="1" set="method"><f a="p1">
	<e path="Bool"/>
	<e path="Void"/>
</f></applyBlendMode>
		<configureBackBuffer public="1" set="method"><f a="p1:p2:p3:p4">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<batchQuad public="1" set="method"><f a="p1:p2:?p3:?p4">
	<c path="starling.display.Quad"/>
	<c path="Float"/>
	<c path="starling.textures.Texture"/>
	<c path="String"/>
	<e path="Void"/>
</f></batchQuad>
		<finishQuadBatch public="1" set="method"><f a=""><e path="Void"/></f></finishQuadBatch>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<raiseDrawCount public="1" set="method">
			<f a="?p1">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p1</e>
	<e>1</e>
</m></meta>
		</raiseDrawCount>
		<mvpMatrix public="1" set="null"><c path="flash.geom.Matrix"/></mvpMatrix>
		<renderTarget public="1"><c path="starling.textures.Texture"/></renderTarget>
		<projectionMatrix public="1" set="null"><c path="flash.geom.Matrix"/></projectionMatrix>
		<backBufferHeight public="1"><c path="Int"/></backBufferHeight>
		<modelViewMatrix public="1" set="null"><c path="flash.geom.Matrix"/></modelViewMatrix>
		<mvpMatrix3D public="1" set="null"><c path="flash.geom.Matrix3D"/></mvpMatrix3D>
		<drawCount public="1" set="null"><c path="Int"/></drawCount>
		<backBufferWidth public="1"><c path="Int"/></backBufferWidth>
		<blendMode public="1"><c path="String"/></blendMode>
		<scissorRectangle public="1"><c path="flash.geom.Rectangle"/></scissorRectangle>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.core.Starling" params="" file="Lib/starling.swf@starling.core.Starling" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<context public="1" set="null" static="1"><c path="flash.display3D.Context3D"/></context>
		<current public="1" set="null" static="1"><c path="starling.core.Starling"/></current>
		<contentScaleFactor public="1" set="null" static="1"><c path="Float"/></contentScaleFactor>
		<juggler public="1" set="null" static="1"><c path="starling.animation.Juggler"/></juggler>
		<handleLostContext public="1" static="1"><e path="Bool"/></handleLostContext>
		<multitouchEnabled public="1" static="1"><e path="Bool"/></multitouchEnabled>
		<VERSION public="1" static="1"><c path="String"/></VERSION>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime>
		<render public="1" set="method"><f a=""><e path="Void"/></f></render>
		<makeCurrent public="1" set="method"><f a=""><e path="Void"/></f></makeCurrent>
		<start public="1" set="method"><f a=""><e path="Void"/></f></start>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<registerProgram public="1" set="method"><f a="p1:p2:p3">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></registerProgram>
		<deleteProgram public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Void"/>
</f></deleteProgram>
		<getProgram public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="flash.display3D.Program3D"/>
</f></getProgram>
		<hasProgram public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Bool"/>
</f></hasProgram>
		<showStatsAt public="1" set="method">
			<f a="?p1:?p2:?p3">
				<c path="String"/>
				<c path="String"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p3</e>
	<e>1</e>
</m></meta>
		</showStatsAt>
		<isStarted public="1" set="null"><e path="Bool"/></isStarted>
		<nativeStage public="1" set="null"><c path="flash.display.Stage"/></nativeStage>
		<stage3D public="1" set="null"><c path="flash.display.Stage3D"/></stage3D>
		<antiAliasing public="1"><c path="Int"/></antiAliasing>
		<nativeOverlay public="1" set="null"><c path="flash.display.Sprite"/></nativeOverlay>
		<root public="1" set="null"><c path="starling.display.DisplayObject"/></root>
		<stage public="1" set="null"><c path="starling.display.Stage"/></stage>
		<simulateMultitouch public="1"><e path="Bool"/></simulateMultitouch>
		<contextData public="1" set="null"><c path="flash.utils.Dictionary"/></contextData>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<profile public="1" set="null"><c path="String"/></profile>
		<showStats public="1"><e path="Bool"/></showStats>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<shareContext public="1"><e path="Bool"/></shareContext>
		<new public="1" set="method"><f a="p1:p2:?p3:?p4:?p5:?p6">
	<c path="Class"><d/></c>
	<c path="flash.display.Stage"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.display.Stage3D"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.display.MovieClip" params="" file="Lib/starling.swf@starling.display.MovieClip" extern="1">
		<extends path="starling.display.Image"/>
		<implements path="starling.animation.IAnimatable"/>
		<addFrame public="1" set="method">
			<f a="p1:?p2:?p3">
				<c path="starling.textures.Texture"/>
				<c path="flash.media.Sound"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p3</e>
	<e>-1</e>
</m></meta>
		</addFrame>
		<addFrameAt public="1" set="method">
			<f a="p1:p2:?p3:?p4">
				<c path="Int"/>
				<c path="starling.textures.Texture"/>
				<c path="flash.media.Sound"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p4</e>
	<e>-1</e>
</m></meta>
		</addFrameAt>
		<removeFrameAt public="1" set="method"><f a="p1">
	<c path="Int"/>
	<e path="Void"/>
</f></removeFrameAt>
		<getFrameTexture public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="starling.textures.Texture"/>
</f></getFrameTexture>
		<setFrameTexture public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></setFrameTexture>
		<getFrameSound public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="flash.media.Sound"/>
</f></getFrameSound>
		<setFrameSound public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="flash.media.Sound"/>
	<e path="Void"/>
</f></setFrameSound>
		<getFrameDuration public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="Float"/>
</f></getFrameDuration>
		<setFrameDuration public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setFrameDuration>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime>
		<isPlaying public="1" set="null"><e path="Bool"/></isPlaying>
		<loop public="1"><e path="Bool"/></loop>
		<isComplete public="1" set="null"><e path="Bool"/></isComplete>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<currentTime public="1" set="null"><c path="Float"/></currentTime>
		<fps public="1"><c path="Float"/></fps>
		<currentFrame public="1"><c path="Int"/></currentFrame>
		<totalTime public="1" set="null"><c path="Float"/></totalTime>
		<new public="1" set="method">
			<f a="p1:?p2">
				<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>12</e>
</m></meta>
		</new>
	</class>
	<class path="starling.display.QuadBatch" params="" file="Lib/starling.swf@starling.display.QuadBatch" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<compile public="1" set="method" static="1"><f a="p1:p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.Vector"><c path="starling.display.QuadBatch"/></c>
	<e path="Void"/>
</f></compile>
		<clone public="1" set="method"><f a=""><c path="starling.display.QuadBatch"/></f></clone>
		<renderCustom public="1" set="method">
			<f a="p1:?p2:?p3">
				<c path="flash.geom.Matrix"/>
				<c path="Float"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>1.</e>
</m></meta>
		</renderCustom>
		<reset public="1" set="method"><f a=""><e path="Void"/></f></reset>
		<addImage public="1" set="method">
			<f a="p1:?p2:?p3:?p4">
				<c path="starling.display.Image"/>
				<c path="Float"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>1.</e>
</m></meta>
		</addImage>
		<addQuad public="1" set="method">
			<f a="p1:?p2:?p3:?p4:?p5:?p6">
				<c path="starling.display.Quad"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
				<c path="String"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>1.</e>
</m></meta>
		</addQuad>
		<addQuadBatch public="1" set="method">
			<f a="p1:?p2:?p3:?p4">
				<c path="starling.display.QuadBatch"/>
				<c path="Float"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>1.</e>
</m></meta>
		</addQuadBatch>
		<isStateChange public="1" set="method">
			<f a="p1:p2:p3:p4:p5:?p6">
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":defparam">
	<e>p6</e>
	<e>1</e>
</m></meta>
		</isStateChange>
		<smoothing public="1" set="null"><c path="String"/></smoothing>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<numQuads public="1" set="null"><c path="Int"/></numQuads>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.display.Stage" params="" file="Lib/starling.swf@starling.display.Stage" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<advanceTime public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></advanceTime>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<color public="1"><t path="UInt"/></color>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<new public="1" set="method">
			<f a="p1:p2:?p3">
				<c path="Int"/>
				<c path="Int"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p3</e>
	<e>0</e>
</m></meta>
		</new>
	</class>
	<class path="starling.events.Event" params="" file="Lib/starling.swf@starling.events.Event" extern="1">
		<toPool public="1" set="method" static="1"><f a="p1">
	<c path="starling.events.Event"/>
	<e path="Void"/>
</f></toPool>
		<fromPool public="1" set="method" static="1">
			<f a="p1:?p2:?p3">
				<c path="String"/>
				<e path="Bool"/>
				<d/>
				<c path="starling.events.Event"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</fromPool>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<REMOVE_FROM_JUGGLER public="1" static="1"><c path="String"/></REMOVE_FROM_JUGGLER>
		<ROOT_CREATED public="1" static="1"><c path="String"/></ROOT_CREATED>
		<CONTEXT3D_CREATE public="1" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<FLATTEN public="1" static="1"><c path="String"/></FLATTEN>
		<TRIGGERED public="1" static="1"><c path="String"/></TRIGGERED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTarget public="1" set="method"><f a="p1">
	<c path="starling.events.EventDispatcher"/>
	<e path="Void"/>
</f></setTarget>
		<setCurrentTarget public="1" set="method"><f a="p1">
	<c path="starling.events.EventDispatcher"/>
	<e path="Void"/>
</f></setCurrentTarget>
		<setData public="1" set="method"><f a="p1">
	<d/>
	<e path="Void"/>
</f></setData>
		<reset public="1" set="method">
			<f a="p1:?p2:?p3">
				<c path="String"/>
				<e path="Bool"/>
				<d/>
				<c path="starling.events.Event"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</reset>
		<stopsPropagation public="1" set="null"><e path="Bool"/></stopsPropagation>
		<type public="1" set="null"><c path="String"/></type>
		<stopsImmediatePropagation public="1" set="null"><e path="Bool"/></stopsImmediatePropagation>
		<target public="1" set="null"><c path="starling.events.EventDispatcher"/></target>
		<currentTarget public="1" set="null"><c path="starling.events.EventDispatcher"/></currentTarget>
		<data public="1" set="null"><d/></data>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method">
			<f a="p1:?p2:?p3">
				<c path="String"/>
				<e path="Bool"/>
				<d/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</new>
	</class>
	<class path="starling.events.Touch" params="" file="Lib/starling.swf@starling.events.Touch" extern="1">
		<getLocation public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getLocation>
		<getPreviousLocation public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getPreviousLocation>
		<getMovement public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getMovement>
		<isTouching public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
</f></isTouching>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method"><f a=""><c path="starling.events.Touch"/></f></clone>
		<dispatchEvent public="1" set="method"><f a="p1">
	<c path="starling.events.TouchEvent"/>
	<e path="Void"/>
</f></dispatchEvent>
		<setTarget public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></setTarget>
		<setPosition public="1" set="method"><f a="p1:p2">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<setSize public="1" set="method"><f a="p1:p2">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setPhase public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Void"/>
</f></setPhase>
		<setTapCount public="1" set="method"><f a="p1">
	<c path="Int"/>
	<e path="Void"/>
</f></setTapCount>
		<setTimestamp public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimestamp>
		<setPressure public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></setPressure>
		<height public="1" set="null"><c path="Float"/></height>
		<phase public="1" set="null"><c path="String"/></phase>
		<previousGlobalX public="1" set="null"><c path="Float"/></previousGlobalX>
		<previousGlobalY public="1" set="null"><c path="Float"/></previousGlobalY>
		<globalX public="1" set="null"><c path="Float"/></globalX>
		<id public="1" set="null"><c path="Int"/></id>
		<timestamp public="1" set="null"><c path="Float"/></timestamp>
		<globalY public="1" set="null"><c path="Float"/></globalY>
		<bubbleChain public="1" set="null"><c path="flash.Vector"><c path="starling.events.EventDispatcher"/></c></bubbleChain>
		<tapCount public="1" set="null"><c path="Int"/></tapCount>
		<pressure public="1" set="null"><c path="Float"/></pressure>
		<target public="1" set="null"><c path="starling.display.DisplayObject"/></target>
		<width public="1" set="null"><c path="Float"/></width>
		<new public="1" set="method"><f a="p1:p2:p3:p4:p5">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="starling.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.events.TouchEvent" params="" file="Lib/starling.swf@starling.events.TouchEvent" extern="1">
		<extends path="starling.events.Event"/>
		<TOUCH public="1" static="1"><c path="String"/></TOUCH>
		<getTouches public="1" set="method"><f a="p1:?p2:?p3">
	<c path="starling.display.DisplayObject"/>
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.events.Touch"/></c>
	<c path="flash.Vector"><c path="starling.events.Touch"/></c>
</f></getTouches>
		<getTouch public="1" set="method"><f a="p1:?p2">
	<c path="starling.display.DisplayObject"/>
	<c path="String"/>
	<c path="starling.events.Touch"/>
</f></getTouch>
		<interactsWith public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<e path="Bool"/>
</f></interactsWith>
		<dispatch public="1" set="method"><f a="p1">
	<c path="flash.Vector"><c path="starling.events.EventDispatcher"/></c>
	<e path="Void"/>
</f></dispatch>
		<ctrlKey public="1" set="null"><e path="Bool"/></ctrlKey>
		<shiftKey public="1" set="null"><e path="Bool"/></shiftKey>
		<timestamp public="1" set="null"><c path="Float"/></timestamp>
		<touches public="1" set="null"><c path="flash.Vector"><c path="starling.events.Touch"/></c></touches>
		<new public="1" set="method">
			<f a="p1:p2:?p3:?p4:?p5">
				<c path="String"/>
				<c path="flash.Vector"><c path="starling.events.Touch"/></c>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p5</e>
					<e>true</e>
				</m>
				<m n=":defparam">
					<e>p4</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>false</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.events.TouchPhase" params="" file="Lib/starling.swf@starling.events.TouchPhase" extern="1">
		<ENDED public="1" static="1"><c path="String"/></ENDED>
		<STATIONARY public="1" static="1"><c path="String"/></STATIONARY>
		<MOVED public="1" static="1"><c path="String"/></MOVED>
		<BEGAN public="1" static="1"><c path="String"/></BEGAN>
		<HOVER public="1" static="1"><c path="String"/></HOVER>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.filters.FragmentFilter" params="" file="Lib/starling.swf@starling.filters.FragmentFilter" extern="1">
		<PMA>
			<e path="Bool"/>
			<meta><m n=":protected"/></meta>
		</PMA>
		<STD_VERTEX_SHADER>
			<c path="String"/>
			<meta><m n=":protected"/></meta>
		</STD_VERTEX_SHADER>
		<STD_FRAGMENT_SHADER>
			<c path="String"/>
			<meta><m n=":protected"/></meta>
		</STD_FRAGMENT_SHADER>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<render public="1" set="method"><f a="p1:p2:p3">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.core.RenderSupport"/>
	<c path="Float"/>
	<e path="Void"/>
</f></render>
		<createPrograms set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</createPrograms>
		<activate set="method">
			<f a="p1:p2:p3">
				<c path="Int"/>
				<c path="flash.display3D.Context3D"/>
				<c path="starling.textures.Texture"/>
				<e path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</activate>
		<deactivate set="method">
			<f a="p1:p2:p3">
				<c path="Int"/>
				<c path="flash.display3D.Context3D"/>
				<c path="starling.textures.Texture"/>
				<e path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</deactivate>
		<assembleAgal set="method">
			<f a="?p1:?p2">
				<c path="String"/>
				<c path="String"/>
				<c path="flash.display3D.Program3D"/>
			</f>
			<meta><m n=":protected"/></meta>
		</assembleAgal>
		<cache public="1" set="method"><f a=""><e path="Void"/></f></cache>
		<clearCache public="1" set="method"><f a=""><e path="Void"/></f></clearCache>
		<compile public="1" set="method"><f a="p1">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.QuadBatch"/>
</f></compile>
		<baseTextureID public="1"><c path="Int"/></baseTextureID>
		<vertexPosAtID public="1"><c path="Int"/></vertexPosAtID>
		<mvpConstantID public="1"><c path="Int"/></mvpConstantID>
		<marginX public="1"><c path="Float"/></marginX>
		<isCached public="1" set="null"><e path="Bool"/></isCached>
		<texCoordsAtID public="1"><c path="Int"/></texCoordsAtID>
		<marginY public="1"><c path="Float"/></marginY>
		<numPasses public="1"><c path="Int"/></numPasses>
		<offsetX public="1"><c path="Float"/></offsetX>
		<mode public="1"><c path="String"/></mode>
		<resolution public="1"><c path="Float"/></resolution>
		<offsetY public="1"><c path="Float"/></offsetY>
		<new public="1" set="method">
			<f a="?p1:?p2">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p2</e>
					<e>1.</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>1</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.textures.Texture" params="" file="Lib/starling.swf@starling.textures.Texture" extern="1">
		<uploadAtfData public="1" set="method" static="1">
			<f a="p1:p2:?p3:?p4">
				<c path="flash.display3D.textures.Texture"/>
				<c path="flash.utils.ByteArray"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p4</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>0</e>
				</m>
			</meta>
		</uploadAtfData>
		<uploadBitmapData public="1" set="method" static="1"><f a="p1:p2:p3">
	<c path="flash.display3D.textures.Texture"/>
	<c path="flash.display.BitmapData"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadBitmapData>
		<fromTexture public="1" set="method" static="1"><f a="p1:?p2:?p3">
	<c path="starling.textures.Texture"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<c path="starling.textures.Texture"/>
</f></fromTexture>
		<empty public="1" set="method" static="1">
			<f a="?p1:?p2:?p3:?p4:?p5">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p5</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p4</e>
					<e>true</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>64</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>64</e>
				</m>
			</meta>
		</empty>
		<fromColor public="1" set="method" static="1">
			<f a="p1:p2:?p3:?p4:?p5">
				<c path="Int"/>
				<c path="Int"/>
				<t path="UInt"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p5</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p4</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>4294967295.</e>
				</m>
			</meta>
		</fromColor>
		<fromAtfData public="1" set="method" static="1">
			<f a="p1:?p2:?p3:?p4">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<e path="Bool"/>
				<d/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p3</e>
					<e>true</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>1</e>
				</m>
			</meta>
		</fromAtfData>
		<fromBitmapData public="1" set="method" static="1">
			<f a="p1:?p2:?p3:?p4">
				<c path="flash.display.BitmapData"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p4</e>
					<e>1</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmapData>
		<fromBitmap public="1" set="method" static="1">
			<f a="p1:?p2:?p3:?p4">
				<c path="flash.display.Bitmap"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p4</e>
					<e>1</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmap>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<adjustVertexData public="1" set="method"><f a="p1:p2:p3">
	<c path="starling.utils.VertexData"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></adjustVertexData>
		<root public="1" set="null"><c path="starling.textures.ConcreteTexture"/></root>
		<base public="1" set="null"><c path="flash.display3D.textures.TextureBase"/></base>
		<nativeHeight public="1" set="null"><c path="Float"/></nativeHeight>
		<height public="1" set="null"><c path="Float"/></height>
		<format public="1" set="null"><c path="String"/></format>
		<repeat public="1"><e path="Bool"/></repeat>
		<nativeWidth public="1" set="null"><c path="Float"/></nativeWidth>
		<mipMapping public="1" set="null"><e path="Bool"/></mipMapping>
		<frame public="1" set="null"><c path="flash.geom.Rectangle"/></frame>
		<scale public="1" set="null"><c path="Float"/></scale>
		<premultipliedAlpha public="1" set="null"><e path="Bool"/></premultipliedAlpha>
		<width public="1" set="null"><c path="Float"/></width>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="starling.textures.ConcreteTexture" params="" file="Lib/starling.swf@starling.textures.ConcreteTexture" extern="1">
		<extends path="starling.textures.Texture"/>
		<restoreOnLostContext public="1" set="method"><f a="p1">
	<d/>
	<e path="Void"/>
</f></restoreOnLostContext>
		<optimizedForRenderTexture public="1" set="null"><e path="Bool"/></optimizedForRenderTexture>
		<new public="1" set="method">
			<f a="p1:p2:p3:p4:p5:p6:?p7:?p8">
				<c path="flash.display3D.textures.TextureBase"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p8</e>
					<e>1</e>
				</m>
				<m n=":defparam">
					<e>p7</e>
					<e>false</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.textures.TextureAtlas" params="" file="Lib/starling.swf@starling.textures.TextureAtlas" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<parseAtlasXml set="method">
			<f a="p1">
				<c path="flash.xml.XML"/>
				<e path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</parseAtlasXml>
		<getTexture public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="starling.textures.Texture"/>
</f></getTexture>
		<getTextures public="1" set="method"><f a="?p1:?p2">
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
</f></getTextures>
		<getNames public="1" set="method"><f a="?p1:?p2">
	<c path="String"/>
	<c path="flash.Vector"><c path="String"/></c>
	<c path="flash.Vector"><c path="String"/></c>
</f></getNames>
		<getRegion public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
</f></getRegion>
		<getFrame public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
</f></getFrame>
		<addRegion public="1" set="method"><f a="p1:p2:?p3">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></addRegion>
		<removeRegion public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Void"/>
</f></removeRegion>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<new public="1" set="method"><f a="p1:?p2">
	<c path="starling.textures.Texture"/>
	<c path="flash.xml.XML"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="starling.utils.AssetManager" params="" file="Lib/starling.swf@starling.utils.AssetManager" extern="1">
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<getTexture public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="starling.textures.Texture"/>
</f></getTexture>
		<getTextures public="1" set="method"><f a="?p1:?p2">
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
</f></getTextures>
		<getTextureNames public="1" set="method"><f a="?p1:?p2">
	<c path="String"/>
	<c path="flash.Vector"><c path="String"/></c>
	<c path="flash.Vector"><c path="String"/></c>
</f></getTextureNames>
		<getTextureAtlas public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="starling.textures.TextureAtlas"/>
</f></getTextureAtlas>
		<getSound public="1" set="method"><f a="p1">
	<c path="String"/>
	<c path="flash.media.Sound"/>
</f></getSound>
		<getSoundNames public="1" set="method"><f a="?p1">
	<c path="String"/>
	<c path="flash.Vector"><c path="String"/></c>
</f></getSoundNames>
		<playSound public="1" set="method">
			<f a="p1:?p2:?p3:?p4">
				<c path="String"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundChannel"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p3</e>
					<e>0</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>0</e>
				</m>
			</meta>
		</playSound>
		<addTexture public="1" set="method"><f a="p1:p2">
	<c path="String"/>
	<c path="starling.textures.Texture"/>
	<e path="Void"/>
</f></addTexture>
		<addTextureAtlas public="1" set="method"><f a="p1:p2">
	<c path="String"/>
	<c path="starling.textures.TextureAtlas"/>
	<e path="Void"/>
</f></addTextureAtlas>
		<addSound public="1" set="method"><f a="p1:p2">
	<c path="String"/>
	<c path="flash.media.Sound"/>
	<e path="Void"/>
</f></addSound>
		<removeTexture public="1" set="method">
			<f a="p1:?p2">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>true</e>
</m></meta>
		</removeTexture>
		<removeTextureAtlas public="1" set="method">
			<f a="p1:?p2">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>true</e>
</m></meta>
		</removeTextureAtlas>
		<removeSound public="1" set="method"><f a="p1">
	<c path="String"/>
	<e path="Void"/>
</f></removeSound>
		<purge public="1" set="method"><f a=""><e path="Void"/></f></purge>
		<enqueue public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></enqueue>
		<loadQueue public="1" set="method"><f a="p1">
	<d/>
	<e path="Void"/>
</f></loadQueue>
		<verbose public="1"><e path="Bool"/></verbose>
		<scaleFactor public="1"><c path="Float"/></scaleFactor>
		<useMipMaps public="1"><e path="Bool"/></useMipMaps>
		<new public="1" set="method">
			<f a="?p1:?p2">
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p2</e>
					<e>false</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>-1</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.utils.VertexData" params="" file="Lib/starling.swf@starling.utils.VertexData" extern="1">
		<TEXCOORD_OFFSET public="1" static="1"><c path="Int"/></TEXCOORD_OFFSET>
		<COLOR_OFFSET public="1" static="1"><c path="Int"/></COLOR_OFFSET>
		<POSITION_OFFSET public="1" static="1"><c path="Int"/></POSITION_OFFSET>
		<ELEMENTS_PER_VERTEX public="1" static="1"><c path="Int"/></ELEMENTS_PER_VERTEX>
		<clone public="1" set="method">
			<f a="?p1:?p2">
				<c path="Int"/>
				<c path="Int"/>
				<c path="starling.utils.VertexData"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p2</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p1</e>
					<e>0</e>
				</m>
			</meta>
		</clone>
		<copyTo public="1" set="method">
			<f a="p1:?p2:?p3:?p4">
				<c path="starling.utils.VertexData"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p4</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p3</e>
					<e>0</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>0</e>
				</m>
			</meta>
		</copyTo>
		<append public="1" set="method"><f a="p1">
	<c path="starling.utils.VertexData"/>
	<e path="Void"/>
</f></append>
		<setPosition public="1" set="method"><f a="p1:p2:p3">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<getPosition public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></getPosition>
		<setColor public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setColor>
		<getColor public="1" set="method"><f a="p1">
	<c path="Int"/>
	<t path="UInt"/>
</f></getColor>
		<setAlpha public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setAlpha>
		<getAlpha public="1" set="method"><f a="p1">
	<c path="Int"/>
	<c path="Float"/>
</f></getAlpha>
		<setTexCoords public="1" set="method"><f a="p1:p2:p3">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTexCoords>
		<getTexCoords public="1" set="method"><f a="p1:p2">
	<c path="Int"/>
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></getTexCoords>
		<translateVertex public="1" set="method"><f a="p1:p2:p3">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translateVertex>
		<transformVertex public="1" set="method">
			<f a="p1:p2:?p3">
				<c path="Int"/>
				<c path="flash.geom.Matrix"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p3</e>
	<e>1</e>
</m></meta>
		</transformVertex>
		<setUniformColor public="1" set="method"><f a="p1">
	<t path="UInt"/>
	<e path="Void"/>
</f></setUniformColor>
		<setUniformAlpha public="1" set="method"><f a="p1">
	<c path="Float"/>
	<e path="Void"/>
</f></setUniformAlpha>
		<scaleAlpha public="1" set="method">
			<f a="p1:p2:?p3">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p3</e>
	<e>1</e>
</m></meta>
		</scaleAlpha>
		<getBounds public="1" set="method">
			<f a="?p1:?p2:?p3:?p4">
				<c path="flash.geom.Matrix"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta>
				<m n=":defparam">
					<e>p3</e>
					<e>-1</e>
				</m>
				<m n=":defparam">
					<e>p2</e>
					<e>0</e>
				</m>
			</meta>
		</getBounds>
		<setPremultipliedAlpha public="1" set="method">
			<f a="p1:?p2">
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>true</e>
</m></meta>
		</setPremultipliedAlpha>
		<numVertices public="1"><c path="Int"/></numVertices>
		<premultipliedAlpha public="1" set="null"><e path="Bool"/></premultipliedAlpha>
		<tinted public="1" set="null"><e path="Bool"/></tinted>
		<rawData public="1" set="null"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<new public="1" set="method">
			<f a="p1:?p2">
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":defparam">
	<e>p2</e>
	<e>false</e>
</m></meta>
		</new>
	</class>
</haxe>